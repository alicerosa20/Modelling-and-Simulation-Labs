
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>3&ordm; Laborat&oacute;rio de Modela&ccedil;&atilde;o e Simula&ccedil;&atilde;o 2019/20</title><meta name="generator" content="MATLAB 8.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-05-12"><meta name="DC.source" content="Lab3.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>3&ordm; Laborat&oacute;rio de Modela&ccedil;&atilde;o e Simula&ccedil;&atilde;o 2019/20</h1><!--introduction--><p>Din&acirc;mica de um metr&oacute;nomo b&aacute;sica</p><p>Alice Rosa, n&ordm; 90007</p><p>Beatriz Pereira, n&ordm; 90029</p><p>Grupo 16, Turno 3&ordf; feira &agrave;s 09h00</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Pergunta 5</a></li><li><a href="#5">Pergunta 6</a></li><li><a href="#9">Pergunta 7</a></li><li><a href="#16">Pergunta 8</a></li><li><a href="#19">Pergunta 9</a></li><li><a href="#25">Pergunta 10</a></li><li><a href="#34">Pergunta 11</a></li><li><a href="#38">Pergunta 12</a></li><li><a href="#41">Pergunta 13</a></li></ul></div><h2>Pergunta 5<a name="1"></a></h2><p>Para esta quest&atilde;o foi desenvolvido o seguinte esquema em Simulink para simular as equa&ccedil;&otilde;es de estado obtidas em 2):</p><pre class="codeinput">open(<span class="string">'sim5'</span>);
</pre><img vspace="5" hspace="5" src="Lab3_01.png" alt=""> <pre class="codeinput"><span class="comment">%Par&acirc;metros</span>
L=0.5;
M=0.15;
l=0.4;
m=0.2;
k=3;
beta=0.1;
g=9.8;
J=(m*l^2)+(M/3)*L^2;
dteta_inicial=pi/4;
teta_inicial=0;

sim(<span class="string">'sim5'</span>,8);

figure;
plot(t,teta);
xlabel(<span class="string">'t [s]'</span>); ylabel(<span class="string">'\theta'</span>);
title(<span class="string">'Posi&ccedil;&atilde;o'</span>);
set(gca,<span class="string">'fontsize'</span>,12);

figure;
plot(t,dteta);
xlabel(<span class="string">'t [s]'</span>); ylabel(<span class="string">'$\dot \theta$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
title(<span class="string">'Velocidade Angular'</span>);
set(gca,<span class="string">'fontsize'</span>,12);

figure;
plot(teta,dteta);
xlabel(<span class="string">'\theta'</span>); ylabel(<span class="string">'$\dot \theta$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
title(<span class="string">'Espa&ccedil;o de estados'</span>);
set(gca,<span class="string">'fontsize'</span>,12);
</pre><img vspace="5" hspace="5" src="Lab3_02.png" alt=""> <img vspace="5" hspace="5" src="Lab3_03.png" alt=""> <img vspace="5" hspace="5" src="Lab3_04.png" alt=""> <p>Os gr&aacute;ficos obtidos correspondem ao esperado, para as condi&ccedil;&otilde;es iniciais de posi&ccedil;&atilde;o, <img src="Lab3_eq08288499342375314727.png" alt="$\theta$"> &eacute; 0 e a velocidade angular do bra&ccedil;o inicial &eacute; <img src="Lab3_eq12719111378361454579.png" alt="$\pi$">/4. Com atrito associado ao sistema e nenhum bin&aacute;rio aplicado, passado algum tempo a posi&ccedil;&atilde;o e velocidade do bra&ccedil;o tendem para 0.</p><h2>Pergunta 6<a name="5"></a></h2><p>Nesta quest&atilde;o foi modificado o diagrama anterior por forma a utilizar o bloco 'State-Space'. Neste define-se as matrizes A,B,C e D apresentadas como coment&aacute;rio no c&oacute;digo.</p><pre class="codeinput">open(<span class="string">'sim6'</span>);
</pre><img vspace="5" hspace="5" src="Lab3_05.png" alt=""> <pre class="codeinput">clear
close <span class="string">all</span>

L=0.5;
M=0.15;
l=0.4;
m=0.2;
k=3;
beta=0.1;
g=9.8;
J=(m*l^2)+(M/3)*L^2; <span class="comment">%Momento de in&eacute;rcia</span>
dteta_inicial=pi/4;
teta_inicial=0;
u=[0 0]; <span class="comment">%Bin&aacute;rio externo</span>

<span class="comment">% A=[0 1; ((g*(m*l+(1/2)*M*L)-k)/J) -(beta/J)];</span>
<span class="comment">% B=[0; 1/J];</span>
<span class="comment">% C=[1 0; 0 1];</span>
<span class="comment">% D=[0; 0];</span>

sim(<span class="string">'sim6'</span>,8);

teta=var_est(:,1);
dteta=var_est(:,2);

figure;
plot(teta,dteta);
xlabel(<span class="string">'\theta'</span>); ylabel(<span class="string">'$\dot \theta$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
title(<span class="string">'Espa&ccedil;o de estados'</span>);
set(gca,<span class="string">'fontsize'</span>,14);
</pre><img vspace="5" hspace="5" src="Lab3_06.png" alt=""> <p>O bloco C foi modificado de forma a termos &agrave; sa&iacute;da do bloco tanto o &acirc;ngulo de deflex&atilde;o <img src="Lab3_eq08288499342375314727.png" alt="$\theta$">, como a velocidade angular do bra&ccedil;o, logo, em vez da matriz ser C=[1 0], esta vai ser igual &agrave; matriz identidade, assim y=[ <img src="Lab3_eq08288499342375314727.png" alt="$\theta$"> <img src="Lab3_eq01480818687041280143.png" alt="$\dot \theta$"> ]'. De modo a confirmar a simula&ccedil;&atilde;o, obteve-se o gr&aacute;fico do espa&ccedil;o de estados e verficou-se que &eacute; igual ao obtido anteriormente.</p><h2>Pergunta 7<a name="9"></a></h2><pre class="codeinput">clear
close <span class="string">all</span>

L=0.5;
M=0.15;
l=0.4;
m=0.2;
k=3;
g=9.8;
J=(m*l^2)+(M/3)*L^2;
dteta_inicial=pi/4;
teta_inicial=0;
u=[0 0];
beta_set=[0 1];

<span class="keyword">for</span> i=1:length(beta_set)
beta=beta_set(i);

sim(<span class="string">'sim6'</span>,8);

teta=var_est(:,1);
dteta=var_est(:,2);

figure;
plot(t,teta);
xlabel(<span class="string">'t [s]'</span>); ylabel(<span class="string">'\theta'</span>);
title(<span class="string">'Posi&ccedil;&atilde;o'</span>);
legend(sprintf(<span class="string">'\\beta=%.2f Nms/rad'</span>,beta));
set(gca,<span class="string">'fontsize'</span>,12);

figure;
plot(t,dteta);
xlabel(<span class="string">'t [s]'</span>); ylabel(<span class="string">'$\dot \theta$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
title(<span class="string">'Velocidade Angular'</span>);
legend(sprintf(<span class="string">'\\beta=%.2f Nms/rad'</span>,beta));
set(gca,<span class="string">'fontsize'</span>,12);

figure;
plot(teta,dteta);
xlabel(<span class="string">'\theta'</span>); ylabel(<span class="string">'$\dot \theta$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
title(<span class="string">'Espa&ccedil;o de estados'</span>);
set(gca,<span class="string">'fontsize'</span>,12);

<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="Lab3_07.png" alt=""> <img vspace="5" hspace="5" src="Lab3_08.png" alt=""> <img vspace="5" hspace="5" src="Lab3_09.png" alt=""> <img vspace="5" hspace="5" src="Lab3_10.png" alt=""> <img vspace="5" hspace="5" src="Lab3_11.png" alt=""> <img vspace="5" hspace="5" src="Lab3_12.png" alt=""> <p>Como era de esperar para <img src="Lab3_eq01943888942785439951.png" alt="$\beta=0$">, n&atilde;o h&aacute; atrito a contrariar o movimento do bra&ccedil;o, logo este fica a oscilar indeterminadamente e a curva representativa do espa&ccedil;o de estado das vari&aacute;veis &eacute; uma circunfer&ecirc;ncia. Enquanto que para <img src="Lab3_eq07813526719646221217.png" alt="$\beta=1$">, tem-se <img src="Lab3_eq12986223900136268671.png" alt="$\zeta&gt;1$">, ou seja, o sistema est&aacute; sobreamortecido. Por esta raz&atilde;o, este n&atilde;o chega a oscilar, como podemos observar nos gr&aacute;ficos em fun&ccedil;&atilde;o do tempo, e a posi&ccedil;&atilde;o final da curva no espa&ccedil;o de estados &eacute; a origem.</p><p>Simulou-se o sistema para 4 conjuntos de condi&ccedil;&otilde;es iniciais, em diferentes quadrantes e diferentes amplitudes e obteve-se as respectivas curvas representativas do espa&ccedil;o de estado das vari&aacute;veis. Sobrep&ocirc;s-se a estes gr&aacute;ficos o campo de vectores que define a equa&ccedil;&atilde;o diferencial e que indica a dire&ccedil;&atilde;o seguida pelas traject&oacute;rias de estado em cada ponto.</p><pre class="codeinput">close <span class="string">all</span>

beta=0;
teta_inicial_set=[pi/2 -pi/3 -pi/4 pi/6];
dteta_inicial_set=[pi/2 pi/3 -pi/4 -pi/6];

x1=linspace(-2,2,25);
x2=linspace(-12,12,25);

[x1,x2] = meshgrid(x1,x2);
dx1=x2;
dx2=((g*(m*l+(1/2)*M*L)-k)/J)*x1 -(beta/J)*x2;

figure(1);
quiver(x1,x2,dx1,dx2);
hold <span class="string">on</span>;

<span class="keyword">for</span> i=1:length(dteta_inicial_set)

       teta_inicial=teta_inicial_set(i);
       dteta_inicial=dteta_inicial_set(i);

        sim(<span class="string">'sim6'</span>);

        teta=var_est(:,1);
        dteta=var_est(:,2);

        figure(1);
        p(i)=plot(teta,dteta);
        hold <span class="string">on</span>;

<span class="keyword">end</span>

figure(1);
xlabel(<span class="string">'\theta'</span>); ylabel(<span class="string">'$\dot \theta$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
title(<span class="string">'Espa&ccedil;o de estados para \beta=0 Nms/rad'</span>);
lg=legend([p(1) p(2) p(3) p(4)],<span class="string">'(\pi/2,\pi/2)'</span>,<span class="keyword">...</span>
    <span class="string">'(-\pi/3,\pi/3)'</span>,<span class="keyword">...</span>
    <span class="string">'(-\pi/4,-\pi/4)'</span>,<span class="string">'(\pi/6,-\pi/6)'</span>,<span class="string">'Orientation'</span>,<span class="string">'horizontal'</span>);
set(gca,<span class="string">'fontsize'</span>,12);
xlim([-2 2]); ylim([-14 14]);
set(lg,<span class="string">'fontsize'</span>,9);
</pre><img vspace="5" hspace="5" src="Lab3_13.png" alt=""> <pre class="codeinput">close <span class="string">all</span>

beta=0.1;
teta_inicial_set=[pi/2 -pi/3 -pi/4 pi/6];
dteta_inicial_set=[pi/2 pi/3 -pi/4 -pi/6];

x1=linspace(-2,2,25);
x2=linspace(-10,10,25);

[x1,x2] = meshgrid(x1,x2);
dx1=x2;
dx2=((g*(m*l+(1/2)*M*L)-k)/J)*x1 -(beta/J)*x2;

figure(1);
quiver(x1,x2,dx1,dx2);
hold <span class="string">on</span>;

<span class="keyword">for</span> i=1:length(dteta_inicial_set)

       teta_inicial=teta_inicial_set(i);
       dteta_inicial=dteta_inicial_set(i);

        sim(<span class="string">'sim6'</span>);

        teta=var_est(:,1);
        dteta=var_est(:,2);

        figure(1);
        p(i)=plot(teta,dteta);
        hold <span class="string">on</span>;

<span class="keyword">end</span>

figure(1);
xlabel(<span class="string">'\theta'</span>); ylabel(<span class="string">'$\dot \theta$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
title(<span class="string">'Espa&ccedil;o de estados para \beta=0.1 Nms/rad'</span>);
set(gca,<span class="string">'fontsize'</span>,12);
xlim([-2 2]); ylim([-10 10]);
lg=legend([p(1) p(2) p(3) p(4)],<span class="string">'(\pi/2,\pi/2)'</span>,<span class="string">'(-\pi/3,\pi/3)'</span>,<span class="keyword">...</span>
    <span class="string">'(-\pi/4,-\pi/4)'</span>,<span class="string">'(\pi/6,-\pi/6)'</span>,<span class="string">'Orientation'</span>,<span class="string">'horizontal'</span>);
set(lg,<span class="string">'fontsize'</span>,9)
</pre><img vspace="5" hspace="5" src="Lab3_14.png" alt=""> <pre class="codeinput">close <span class="string">all</span>

beta=1;
teta_inicial_set=[pi/2 -pi/3 -pi/4 pi/6];
dteta_inicial_set=[pi/2 pi/3 -pi/4 -pi/6];

x1=linspace(-2,2,25);
x2=linspace(-5,5,25);

[x1,x2] = meshgrid(x1,x2);
dx1=x2;
dx2=((g*(m*l+(1/2)*M*L)-k)/J)*x1 -(beta/J)*x2;

figure(1);
quiver(x1,x2,dx1,dx2);
hold <span class="string">on</span>;

<span class="keyword">for</span> i=1:length(dteta_inicial_set)

       teta_inicial=teta_inicial_set(i);
       dteta_inicial=dteta_inicial_set(i);

        sim(<span class="string">'sim6'</span>);

        teta=var_est(:,1);
        dteta=var_est(:,2);

        figure(1);
        p(i)=plot(teta,dteta);
        hold <span class="string">on</span>;

<span class="keyword">end</span>

figure(1);
xlabel(<span class="string">'\theta'</span>); ylabel(<span class="string">'$\dot \theta$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
title(<span class="string">'Espa&ccedil;o de estados para \beta=1 Nms/rad'</span>);
set(gca,<span class="string">'fontsize'</span>,12);
xlim([-2 2]);
lg=legend([p(1) p(2) p(3) p(4)],<span class="string">'(\pi/2,\pi/2)'</span>,<span class="string">'(-\pi/3,\pi/3)'</span>,<span class="keyword">...</span>
    <span class="string">'(-\pi/4,-\pi/4)'</span>,<span class="string">'(\pi/6,-\pi/6)'</span>,<span class="string">'Orientation'</span>,<span class="string">'horizontal'</span>);
set(lg,<span class="string">'fontsize'</span>,9)
</pre><img vspace="5" hspace="5" src="Lab3_15.png" alt=""> <pre class="codeinput">L=0.5;
M=0.15;
l=0.4;
m=0.2;
k=3;
g=9.8;
J=(m*l^2)+(M/3)*L^2;

<span class="keyword">for</span> beta=[0 0.1 1]
A=[0 1; ((g*(m*l+(1/2)*M*L)-k)/J) -(beta/J)];

Valores_proprios=eig(A);
[Vectores_proprios,~] = eig(A);
display(beta);
display(Valores_proprios);
display(Vectores_proprios);

<span class="keyword">end</span>
</pre><pre class="codeoutput">
beta =

     0


Valores_proprios =

   0.0000 + 6.4451i
   0.0000 - 6.4451i


Vectores_proprios =

   0.0000 - 0.1533i   0.0000 + 0.1533i
   0.9882 + 0.0000i   0.9882 + 0.0000i


beta =

    0.1000


Valores_proprios =

  -1.1236 + 6.3464i
  -1.1236 - 6.3464i


Vectores_proprios =

  -0.0267 - 0.1510i  -0.0267 + 0.1510i
   0.9882 + 0.0000i   0.9882 + 0.0000i


beta =

     1


Valores_proprios =

   -2.0323
  -20.4396


Vectores_proprios =

    0.4415   -0.0489
   -0.8973    0.9988

</pre><div><ul><li>Para <img src="Lab3_eq01943888942785439951.png" alt="$\beta=0$"> Nms/rad, os valores pr&oacute;prios s&atilde;o imagin&aacute;rios puros e os gr&aacute;ficos obtidos s&atilde;o circunfer&ecirc;ncias centradas na origem cujo raio depende apenas da amplitude das condi&ccedil;&otilde;es iniciais. Esta din&acirc;mica ocorre quando os p&oacute;los do sistema est&atilde;o situados no eixo imagin&aacute;rio e, uma vez que p&oacute;los=Valores pr&oacute;prios da matriz A, confirma-se os resultados obtidos.</li></ul></div><div><ul><li>Para <img src="Lab3_eq02417156135643290836.png" alt="$\beta=0.1$"> Nms/rad, os gr&aacute;ficos obtidos s&atilde;o espiras que se iniciam no ponto correspondente &agrave;s condi&ccedil;&otilde;es iniciais e terminam na origem. Esta din&acirc;mica ocorre quando os p&oacute;los do sistema est&atilde;o situados no semi-plano complexo esquerdo, verificado pela parte real dos valores pr&oacute;prios.</li></ul></div><div><ul><li>Para <img src="Lab3_eq07813526719646221217.png" alt="$\beta=1$"> Nms/rad, todas as curvas t&ecirc;m in&iacute;cio nas suas condi&ccedil;&otilde;es iniciais e evoluem at&eacute; chegar a um ponto em que se deslocam linearmente para a origem. Esta din&acirc;mica ocorre quando os p&oacute;los do sistema est&atilde;o situados no eixo real do semi-plano complexo esquerdo, como confirmado pelos valores pr&oacute;prios obtidos.</li></ul></div><h2>Pergunta 8<a name="16"></a></h2><pre class="codeinput">clear
close <span class="string">all</span>

L=0.5;
M=0.15;
l=0.4;
m=0.2;
k=3;
beta=0.1;
g=9.8;
J=(m*l^2)+(M/3)*L^2;
u=[0 0];

beta=1;
teta_inicial_set=[-0.0489 0.4415];
dteta_inicial_set=[0.9900 -0.8973];

<span class="keyword">for</span> i=1:length(dteta_inicial_set)

       teta_inicial=teta_inicial_set(i);
       dteta_inicial=dteta_inicial_set(i);

        sim(<span class="string">'sim6'</span>);

        teta=var_est(:,1);
        dteta=var_est(:,2);

        figure(1);
        plot(teta,dteta,<span class="string">'LineWidth'</span>,1);
        hold <span class="string">on</span>;
<span class="keyword">end</span>

figure(1);
xlabel(<span class="string">'\theta'</span>); ylabel(<span class="string">'$\dot \theta$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
title(<span class="string">'Espa&ccedil;o de estados'</span>);
set(gca,<span class="string">'fontsize'</span>,12);
legend(sprintf(<span class="string">'(%.3f,%.3f)'</span>,teta_inicial_set(1),dteta_inicial_set(1)),<span class="keyword">...</span>
    sprintf(<span class="string">'(%.3f,%.3f)'</span>,teta_inicial_set(2),dteta_inicial_set(2)));
xlim([-2 2]);
</pre><img vspace="5" hspace="5" src="Lab3_16.png" alt=""> <p>A escolha dos dois conjuntos de condi&ccedil;&otilde;es iniciais &eacute; indicada no documento 'QuestoesTeoricas-Lab3-Grupo16.pdf'. O gr&aacute;fico obtido serve de confirma&ccedil;&atilde;o dessa escolha.</p><h2>Pergunta 9<a name="19"></a></h2><p>Para esta quest&atilde;o criaram-se tr&ecirc;s fun&ccedil;&otilde;es, a primeira 'freq_to_bpm' apenas converte a frequ&ecirc;ncia de oscila&ccedil;&atilde;o obtida em BPM.</p><p>A segunda, denominada 'calc_media_BPM' &eacute; utilizada para calcular uma m&eacute;dia das frequ&ecirc;ncias medidas entre os v&aacute;rios picos do sinal, de forma a diminuir o erro.</p><p>A terceira, denominada 'parametros_estimados' &eacute; a utilizada para a estimativa de m, l1 (comprimento de l que permite obter no metr&oacute;nomo a cad&ecirc;ncia de 53 BPM) e l2 (cad&ecirc;ncia de 141 BPM).</p><p>A descri&ccedil;&atilde;o da estrat&eacute;gia de dimensionamento &eacute; indicada no documento 'QuestoesTeoricas-Lab3-Grupo16.pdf'. No entanto, &eacute; importante referir que foi feita a aproxima&ccedil;&atilde;o <img src="Lab3_eq16721509177793737761.png" alt="$w_n\approx w_a$">, pois <img src="Lab3_eq12376959470349231365.png" alt="$w_a=w_n\sqrt{1-\zeta^2}$"> e para valores de <img src="Lab3_eq17331442575217596290.png" alt="$\beta$"> baixos <img src="Lab3_eq08546653028945028860.png" alt="$\zeta\approx 0$">.</p><pre class="codeinput">type(<span class="string">'freq_to_bpm.m'</span>);
</pre><pre class="codeoutput">
function BPM=freq_to_bpm(wn)

f_osc=wn/(2*pi);
f_bat=2*f_osc;
BPM=60*f_bat;

end
</pre><pre class="codeinput">type(<span class="string">'calc_media_BPM'</span>);
</pre><pre class="codeoutput">
function media_BPM=calc_media_BPM(t,locs,ind_inicial)
k=1;

for i=ind_inicial:(length(locs)-1)
    f_osc=1/(t(locs(i+1))-t(locs(i)));
    BPM(k)=60*(2*f_osc);
    k=k+1;
end

media_BPM=mean(BPM);

end
</pre><pre class="codeinput">type(<span class="string">'parametros_estimados.m'</span>);
</pre><pre class="codeoutput">
function [BPM_obt,ind_r,l,m]=parametros_estimados(BPM,valor_esperado,m_set,l_set)

[r,c] = size(BPM);
erro_min=50;

for i=1:r
    for j=1:c
        if isnan(BPM(i,j)) %Se o valor de BPM n&atilde;o &eacute; v&aacute;lido continua
            continue;
        end
         %Erro entre a frequ&ecirc;ncia pretendida e a medida para o par (m,l)
        erro=abs(BPM(i,j)-valor_esperado);
        
        %Guardar os ind&iacute;ces que levam ao erro m&iacute;nimo
        if erro&lt;erro_min
            ind_r=i;
            ind_c=j;
            BPM_obt=BPM(i,j);
            erro_min=erro;
        end
    end
end

m=m_set(ind_r);
l=l_set(ind_c);

end
</pre><pre class="codeinput">clear
close <span class="string">all</span>

L=0.25;
M=0.1;
k=0.35;
g=9.8;
beta=0.001;

m_set=linspace(0,0.1,200); <span class="comment">%valores de m</span>
l_set=linspace(0.05,0.25,200); <span class="comment">%valores de l</span>

<span class="keyword">for</span> i=1:length(m_set)
    m=m_set(i);
    <span class="keyword">for</span> j=1:length(l_set)
        l=l_set(j);

        J=(m*l^2)+(M/3)*L^2;

        <span class="keyword">if</span> (k-g*(m*l+(1/2)*M*L))/J&lt;0
            BPM(i,j)=NaN;
            <span class="keyword">continue</span>;
        <span class="keyword">end</span>
        <span class="comment">%C&aacute;lculo da frequ&ecirc;ncia natural das oscila&ccedil;&otilde;es amortecidas</span>
        wn=sqrt((k-g*(m*l+(1/2)*M*L))/J);
        <span class="comment">%C&aacute;lculo da frequ&ecirc;ncia em BPM</span>
        BPM(i,j)=freq_to_bpm(wn);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%Varia&ccedil;&atilde;o da frequ&ecirc;cia com a massa e o comprimento l</span>

figure(1);
surfc(m_set,l_set,BPM);
shading <span class="string">interp</span>;
view(130, 30);
ylabel(<span class="string">'l [m]'</span>); xlabel(<span class="string">'m [Kg]'</span>); zlabel(<span class="string">'Frequ&ecirc;ncia [BPM]'</span>);

<span class="comment">%C&aacute;lculos de m,l1 e l2</span>
[BPM1,ind_r,l1,m_est]=parametros_estimados(BPM,53,m_set,l_set);
[BPM2,~,l2,~]=parametros_estimados(BPM(ind_r,:),141,m_set,l_set);

<span class="comment">% (m,l1)</span>
dteta_inicial=0;
teta_inicial=pi/4;
u=[0 0];
m=m_est;
l=l1;
J=(m*l^2)+(M/3)*L^2;
sim(<span class="string">'sim6'</span>,25);

teta=var_est(:,1);
[~,locs] = findpeaks(teta);
ind_inicial=1;
media_BPM1=calc_media_BPM(t,locs,ind_inicial);

<span class="comment">%Envolvente</span>
wn=sqrt((k-g*(m*l+(1/2)*M*L))/J);
zeta=beta/(2*J*wn);

env=(pi/4)*exp(-zeta*wn*t);

<span class="comment">%Plot para 53 BPM</span>
figure(2);
plot(t,teta,t,env,<span class="string">'r'</span>,t,-env,<span class="string">'r'</span>);
xlabel(<span class="string">'t [s]'</span>); ylabel(<span class="string">'\theta'</span>);
title(<span class="string">'Posi&ccedil;&atilde;o em fun&ccedil;&atilde;o do tempo '</span>); set(gca,<span class="string">'fontsize'</span>,12);
legend(sprintf(<span class="string">'\\theta(t) - %.2f BPM'</span>,media_BPM1),<span class="string">'Envolvente Te&oacute;rica'</span>);

<span class="comment">% (m,l2)</span>
l=l2;
J=(m*l^2)+(M/3)*L^2;
sim(<span class="string">'sim6'</span>,25);

teta=var_est(:,1);
[~,locs] = findpeaks(teta);
ind_inicial=1;
media_BPM2=calc_media_BPM(t,locs,ind_inicial);


<span class="comment">%Envolvente</span>
wn=sqrt((k-g*(m*l+(1/2)*M*L))/J);
zeta=beta/(2*J*wn);

env=(pi/4)*exp(-zeta*wn*t);

<span class="comment">%Plot para 141 BPM</span>
figure(3);
plot(t,teta,t,env,<span class="string">'r'</span>,t,-env,<span class="string">'r'</span>);
xlabel(<span class="string">'t [s]'</span>); ylabel(<span class="string">'\theta'</span>);
title(<span class="string">'Posi&ccedil;&atilde;o em fun&ccedil;&atilde;o do tempo '</span>); set(gca,<span class="string">'fontsize'</span>,12);
legend(sprintf(<span class="string">'\\theta(t) - %.2f BPM'</span>,media_BPM2),<span class="string">'Envolvente Te&oacute;rica'</span>);

<span class="comment">%Dimensionamento</span>

fprintf(<span class="string">'m estimado: %.4f\n'</span>,m_est);
fprintf(<span class="string">'l1 estimado: %.4f\n'</span>,l1);
fprintf(<span class="string">'Frequ&ecirc;ncia em BPM obtida: %.2f\n'</span>,media_BPM1);
fprintf(<span class="string">'l2 estimado: %.4f\n'</span>,l2);
fprintf(<span class="string">'Frequ&ecirc;ncia em BPM obtida: %.2f\n'</span>,media_BPM2);
</pre><pre class="codeoutput">m estimado: 0.0799
l1 estimado: 0.2289
Frequ&ecirc;ncia em BPM obtida: 52.98
l2 estimado: 0.0952
Frequ&ecirc;ncia em BPM obtida: 140.88
</pre><img vspace="5" hspace="5" src="Lab3_17.png" alt=""> <img vspace="5" hspace="5" src="Lab3_18.png" alt=""> <img vspace="5" hspace="5" src="Lab3_19.png" alt=""> <p>A envolvente obtida adequa-se bem aos gr&aacute;ficos obtidos. Obteve-se, aproximadamente, a frequ&ecirc;ncia pretendida para as duas cad&ecirc;ncias o que confirma a validade da estrat&eacute;gia utilizada.</p><h2>Pergunta 10<a name="25"></a></h2><p>Para esta quest&atilde;o foi desenvolvido o seguinte esquema em Simulink para simular o modelo n&atilde;o linear do metr&oacute;nomo:</p><pre class="codeinput">open(<span class="string">'sim10'</span>);
</pre><img vspace="5" hspace="5" src="Lab3_20.png" alt=""> <p>Em que o bloco 'MATLAB Function' apresenta o seguinte c&oacute;digo:</p><pre class="codeinput">type(<span class="string">'fcn.m'</span>);
</pre><pre class="codeoutput">
function d2teta = fcn(teta,dteta, T, m, l, M, L, g, k, beta)
%#codegen
J=(m*l^2)+(M/3)*L^2;
d2teta =(1/J)*(-k*teta*(1+(teta^2/100))-beta*dteta+g*sin(teta)*(m*l+(1/2)*M*L)+T);
</pre><p>Foram criadas duas fun&ccedil;&otilde;es para se utilizar na fun&ccedil;&atilde;o fminsearch, de forma a encontrar-se o par&acirc;metro l que diminui o erro=BPM pretendido-BPM simulado, sem ter de se utilizar uma procura extensiva.</p><p>A fun&ccedil;&atilde;o que obt&eacute;m o comprimento l que permite ter no metr&oacute;nomo a cad&ecirc;ncia de 53 BPM &eacute;:</p><pre class="codeinput">type(<span class="string">'calc_erro_l1.m'</span>);
</pre><pre class="codeoutput">
function y=calc_erro_l1(x)
% Defenir novo workspace de simula&ccedil;&atilde;o
options = simset('SrcWorkspace','current'); 
%Par&acirc;metros
L=0.25;
M=0.1;
k=0.35;
g=9.8;
beta=0.001;
dteta_inicial=0;
teta_inicial=pi/4;
T=0;
m=0.0799;
l=x;

sim('sim10',40,options);

[~,locs] = findpeaks(teta);
ind_inicial=10;
media_BPM=calc_media_BPM(t,locs,ind_inicial);

y=abs(53-media_BPM);

end
</pre><p>A fun&ccedil;&atilde;o que obt&eacute;m o comprimento l que permite ter no metr&oacute;nomo a cad&ecirc;ncia de 141 BPM &eacute;:</p><pre class="codeinput">type(<span class="string">'calc_erro_l2.m'</span>);
</pre><pre class="codeoutput">
function y=calc_erro_l2(x)

options = simset('SrcWorkspace','current');

L=0.25;
M=0.1;
k=0.35;
g=9.8;
beta=0.001;
dteta_inicial=0;
teta_inicial=pi/4;
T=0;
m=0.0799;
l=x;

sim('sim10',40,options);

[~,locs] = findpeaks(teta);
ind_inicial=10;
media_BPM=calc_media_BPM(t,locs,ind_inicial);

y=abs(141-media_BPM);

end
</pre><pre class="codeinput">clear
close <span class="string">all</span>

L=0.25;
M=0.1;
k=0.35;
g=9.8;
beta=0.001;
dteta_inicial=0;
teta_inicial=pi/4;
T=0;
m=0.0799;
l=0.2289;
sim(<span class="string">'sim10'</span>,40);

[~,locs] = findpeaks(teta);
<span class="comment">%inicia-se a m&eacute;dia no ind&iacute;ce 10 para dar tempo ao transit&oacute;rio de se</span>
<span class="comment">%extinguir</span>
ind_inicial=10;
media_BPM1=calc_media_BPM(t,locs,ind_inicial);
desvio_freq_1=abs(53-media_BPM1);
display(desvio_freq_1)

<span class="comment">% (m,l2)</span>
l=0.0952;
sim(<span class="string">'sim10'</span>,40);

[~,locs] = findpeaks(teta);
ind_inicial=10;
media_BPM2=calc_media_BPM(t,locs,ind_inicial);
desvio_freq_2=abs(141-media_BPM2);
display(desvio_freq_2)

<span class="comment">% Refinamento do dimensionamento</span>

<span class="comment">%l1</span>
l1=0.2289;
xo=l1;
fun=@calc_erro_l1;
[l1_est,erro]=fminsearch(fun,xo);
display(erro)
display(l1_est)

<span class="comment">%l2</span>
l2=0.0952;
xo=l2;
fun=@calc_erro_l2;
[l2_est,erro]=fminsearch(fun,xo);
display(erro)
display(l2_est)

<span class="comment">%Plot</span>

<span class="keyword">for</span> l=[l1_est l2_est]
    sim(<span class="string">'sim10'</span>,40);

    [~,locs] = findpeaks(teta);
    ind_inicial=10;
    media_BPM=calc_media_BPM(t,locs,ind_inicial);

    figure;
    plot(t,teta);
    xlabel(<span class="string">'t [s]'</span>); ylabel(<span class="string">'\theta'</span>);
    title(<span class="string">'Posi&ccedil;&atilde;o em fun&ccedil;&atilde;o do tempo '</span>); set(gca,<span class="string">'fontsize'</span>,12);
    legend(sprintf(<span class="string">'\\theta(t) - %.2f BPM'</span>,media_BPM));
<span class="keyword">end</span>
</pre><pre class="codeoutput">
desvio_freq_1 =

    0.1569


desvio_freq_2 =

    0.0454


erro =

    0.0099


l1_est =

    0.2291


erro =

    0.0434


l2_est =

    0.0951

</pre><img vspace="5" hspace="5" src="Lab3_21.png" alt=""> <img vspace="5" hspace="5" src="Lab3_22.png" alt=""> <h2>Pergunta 11<a name="34"></a></h2><p>Nesta quest&atilde;o foi modificado o diagrama anterior, por forma a simular a exist&ecirc;ncia de um mecanismo de relojoaria no metr&oacute;nomo que impulsiona durante breves instantes o p&ecirc;ndulo quando este passa na vertical.</p><p>Para este efeito, utilizou-se um bloco 'Switch' para que se <img src="Lab3_eq10466040466111255185.png" alt="$| \theta |<int$">, se aplique um bin&aacute;rio externo cujo o valor &eacute; 7 vezes superior &agrave; for&ccedil;a de atrito aplicada, de forma a contrariar a mesma e a evitar o decaimento natural para zero da amplitude das oscila&ccedil;&otilde;es.</p><pre class="codeinput">open(<span class="string">'sim11'</span>);
</pre><img vspace="5" hspace="5" src="Lab3_23.png" alt=""> <pre class="codeinput">close <span class="string">all</span>
clear

L=0.25;
M=0.1;
k=0.35;
g=9.8;
beta=0.001;
dteta_inicial=0;
teta_inicial=pi/4;
int=0.1;
i=1;

m=0.0799;
<span class="comment">%Par&acirc;metros estimados na al&iacute;nea 10</span>
l1=0.2291;
l2=0.0951;

<span class="keyword">for</span> l=[l1 l2]
sim(<span class="string">'sim11'</span>,40);

[~,locs] = findpeaks(teta);
ind_inicial=10;
BPM(i)=calc_media_BPM(t,locs,ind_inicial);

figure;
plot(t,teta);
xlabel(<span class="string">'t [s]'</span>); ylabel(<span class="string">'\theta'</span>);
title(<span class="string">'Posi&ccedil;&atilde;o em fun&ccedil;&atilde;o do tempo '</span>); set(gca,<span class="string">'fontsize'</span>,12);
legend(sprintf(<span class="string">'\\theta(t) - %.2f BPM'</span>,BPM(i)));
figure;
plot(t,T);
xlabel(<span class="string">'t [s]'</span>); ylabel(<span class="string">'T'</span>);
title(<span class="string">'Bin&aacute;rio externo aplicado'</span>); set(gca,<span class="string">'fontsize'</span>,12);

i=i+1;
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="Lab3_24.png" alt=""> <img vspace="5" hspace="5" src="Lab3_25.png" alt=""> <img vspace="5" hspace="5" src="Lab3_26.png" alt=""> <img vspace="5" hspace="5" src="Lab3_27.png" alt=""> <p>Quando se aplica o bin&aacute;rio externo verifica-se uma mudan&ccedil;a na frequ&ecirc;ncia de oscila&ccedil;&atilde;o relativamente &agrave; pretendida, principalmente para a frequ&ecirc;ncia mais baixa. Para acertar teria de se considerar o bin&aacute;rio externo no dimensionamento de l.</p><h2>Pergunta 12<a name="38"></a></h2><pre class="codeinput">clear
close <span class="string">all</span>

L=0.25;
M=0.1;
k=0.35;
g=9.8;
beta=0.001;
dteta_inicial=0;
teta_inicial=pi/4;

m=0.0799;
<span class="comment">%Par&acirc;metros estimados na quest&atilde;o 9</span>
l1=0.2289;
l2=0.0952;

<span class="keyword">for</span> l=[l1 l2]

J=(m*l^2)+(M/3)*L^2;
G=1/(k-g*(m*l+(1/2)*M*L));
wn=sqrt((k-g*(m*l+(1/2)*M*L))/J);
zeta=beta/(2*J*wn);

H=tf(G*wn^2,[1 2*zeta*wn wn^2]);
w = linspace(10e-2,10e2,10e5);

figure(1);
h=bodeplot(H,w);
hold <span class="string">on</span>;
<span class="keyword">end</span>

p = getoptions(h);
p.YLim{1}=[-40 60];
setoptions(h,p);
figure(1);
legend(<span class="string">'53 BPM'</span>,<span class="string">'141 BPM'</span>);
</pre><img vspace="5" hspace="5" src="Lab3_28.png" alt=""> <p>Os diagramas de bode obtidos para as duas posi&ccedil;&otilde;es da massa s&atilde;o semelhantes, as principais diferen&ccedil;as prendem-se com o facto do "pico" da amplitude ocorrer na frequ&ecirc;ncia de oscila&ccedil;&atilde;o 53 BPM para l=0.2289 e em 141 BPM para l=0.0952 e que para a menor frequ&ecirc;ncia obt&eacute;m-se um maior ganho de amplitude.</p><p>O dispositivo que poderia fornecer a este sistema mec&acirc;nico o tipo de entrada subjacente ao diagrama de Bode &eacute; um filtro passa-baixo com um p&oacute;lo duplo, pois a partir da frequ&ecirc;ncia de corte a amplitude do diagrama diminui 40 dB/dec.</p><h2>Pergunta 13<a name="41"></a></h2><p>Para esta quest&atilde;o foi criado um diagrama de blocos em Simulink, onde se aplica um bin&aacute;rio externo sinusoidal com frequ&ecirc;ncia ajust&aacute;vel e &agrave; sa&iacute;da do bloco da fun&ccedil;&atilde;o de transfer&ecirc;ncia do sistema linear temos o valor de <img src="Lab3_eq08288499342375314727.png" alt="$\theta$">.</p><pre class="codeinput">open(<span class="string">'sim13'</span>);
</pre><img vspace="5" hspace="5" src="Lab3_29.png" alt=""> <pre class="codeinput">clear
close <span class="string">all</span>

L=0.25;
M=0.1;
k=0.35;
g=9.8;
beta=0.001;
dteta_inicial=0;
teta_inicial=pi/4;
m=0.0799;
l=0.2289;
i=1;

J=(m*l^2)+(M/3)*L^2;
G=1/(k-g*(m*l+(1/2)*M*L));
wn=sqrt((k-g*(m*l+(1/2)*M*L))/J);
zeta=beta/(2*J*wn);

<span class="comment">%testa-se para as frequ&ecirc;ncias angulares entre 2 e 3 rad/s</span>
w_teste_set=2:0.01:3;

<span class="keyword">for</span> i=1:length(w_teste_set)

w_teste=w_teste_set(i);
sim(<span class="string">'sim13'</span>,50);

<span class="comment">%Obt&eacute;m-se o valor m&aacute;ximo de cada gr&aacute;fico obtido</span>
amp(i)=max(teta);

<span class="keyword">end</span>

<span class="comment">%Encontra-se a frequ&ecirc;ncia para a qual teta apresenta maior amplitude</span>
[~,ind]=max(amp);

<span class="comment">%Obt&eacute;m-se wn</span>
w_esc=w_teste_set(ind);

<span class="comment">%Calcula-se a massa com o valor de wn</span>
m_calc=(k-J*w_esc^2-g*(1/2)*M*L)/(g*l);

fprintf(<span class="string">'massa real: %.4f \nmassa estimada: %.4f\n'</span>,m,m_calc);
</pre><pre class="codeoutput">massa real: 0.0799 
massa estimada: 0.0800
</pre><p>A descri&ccedil;&atilde;o da estrat&eacute;gia da medi&ccedil;&atilde;o da massa encontra-se no documento 'QuestoesTeoricas-Lab3-Grupo16.pdf'.</p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% 3º Laboratório de Modelação e Simulação 2019/20
% Dinâmica de um metrónomo básica
%
% Alice Rosa, nº 90007 
%
% Beatriz Pereira, nº 90029 
%
% Grupo 16, Turno 3ª feira às 09h00 
%% Pergunta 5
% Para esta questão foi desenvolvido o seguinte esquema em Simulink para 
% simular as equações de estado obtidas em 2):
%%
open('sim5');
%%

%Parâmetros
L=0.5;
M=0.15;
l=0.4;
m=0.2;
k=3;
beta=0.1;
g=9.8;
J=(m*l^2)+(M/3)*L^2;
dteta_inicial=pi/4;
teta_inicial=0;

sim('sim5',8);

figure;
plot(t,teta);
xlabel('t [s]'); ylabel('\theta');
title('Posição');
set(gca,'fontsize',12);

figure;
plot(t,dteta);
xlabel('t [s]'); ylabel('$\dot \theta$','interpreter','latex');
title('Velocidade Angular');
set(gca,'fontsize',12);

figure;
plot(teta,dteta);
xlabel('\theta'); ylabel('$\dot \theta$','interpreter','latex');
title('Espaço de estados');
set(gca,'fontsize',12);
%%
% Os gráficos obtidos correspondem ao esperado, para as condições iniciais de
% posição, $\theta$ é 0 e a velocidade angular do braço inicial é $\pi$/4. 
% Com atrito associado ao sistema e nenhum binário aplicado, passado algum 
% tempo a posição e velocidade do braço tendem para 0.

%% Pergunta 6
% Nesta questão foi modificado o diagrama anterior por forma a utilizar 
% o bloco 'State-Space'. Neste define-se as matrizes A,B,C e D apresentadas
% como comentário no código.
%%
open('sim6');
%%
clear 
close all

L=0.5;
M=0.15;
l=0.4;
m=0.2;
k=3;
beta=0.1;
g=9.8;
J=(m*l^2)+(M/3)*L^2; %Momento de inércia
dteta_inicial=pi/4;
teta_inicial=0;
u=[0 0]; %Binário externo

% A=[0 1; ((g*(m*l+(1/2)*M*L)-k)/J) -(beta/J)];
% B=[0; 1/J];
% C=[1 0; 0 1];
% D=[0; 0];

sim('sim6',8);

teta=var_est(:,1);
dteta=var_est(:,2);

figure;
plot(teta,dteta);
xlabel('\theta'); ylabel('$\dot \theta$','interpreter','latex');
title('Espaço de estados');
set(gca,'fontsize',14);

%%
% O bloco C foi modificado de forma a termos à saída do bloco tanto o
% ângulo de deflexão $\theta$, como a velocidade angular do braço,
% logo, em vez da matriz ser C=[1 0], esta vai ser igual à matriz identidade,
% assim y=[ $\theta$ $\dot \theta$ ]'.
% De modo a confirmar a simulação, obteve-se o gráfico do espaço de estados e
% verficou-se que é igual ao obtido anteriormente.

%% Pergunta 7
clear
close all

L=0.5;
M=0.15;
l=0.4;
m=0.2;
k=3;
g=9.8;
J=(m*l^2)+(M/3)*L^2;
dteta_inicial=pi/4;
teta_inicial=0;
u=[0 0];
beta_set=[0 1];

for i=1:length(beta_set)
beta=beta_set(i);

sim('sim6',8);

teta=var_est(:,1);
dteta=var_est(:,2);

figure;
plot(t,teta);
xlabel('t [s]'); ylabel('\theta');
title('Posição');
legend(sprintf('\\beta=%.2f Nms/rad',beta));
set(gca,'fontsize',12);

figure;
plot(t,dteta);
xlabel('t [s]'); ylabel('$\dot \theta$','interpreter','latex');
title('Velocidade Angular');
legend(sprintf('\\beta=%.2f Nms/rad',beta));
set(gca,'fontsize',12);

figure;
plot(teta,dteta);
xlabel('\theta'); ylabel('$\dot \theta$','interpreter','latex');
title('Espaço de estados');
set(gca,'fontsize',12);

end

%%
% Como era de esperar para $\beta=0$, não há atrito a contrariar o
% movimento do braço, logo este fica a oscilar indeterminadamente e a curva
% representativa do espaço de estado das variáveis é uma circunferência. Enquanto
% que para $\beta=1$, tem-se $\zeta>1$, ou seja, o sistema está sobreamortecido.
% Por esta razão, este não chega a oscilar, como podemos observar nos gráficos
% em função do tempo, e a posição final da curva no espaço de estados é a origem.
%
% Simulou-se o sistema para 4 conjuntos de condições iniciais, em
% diferentes quadrantes e diferentes amplitudes e obteve-se as respectivas
% curvas representativas do espaço de estado das variáveis. Sobrepôs-se a
% estes gráficos o campo de vectores que define a equação diferencial e
% que indica a direção seguida pelas trajectórias de estado em cada ponto.
%% 
close all

beta=0; 
teta_inicial_set=[pi/2 -pi/3 -pi/4 pi/6];
dteta_inicial_set=[pi/2 pi/3 -pi/4 -pi/6]; 

x1=linspace(-2,2,25);
x2=linspace(-12,12,25);

[x1,x2] = meshgrid(x1,x2);
dx1=x2;
dx2=((g*(m*l+(1/2)*M*L)-k)/J)*x1 -(beta/J)*x2;

figure(1);
quiver(x1,x2,dx1,dx2);
hold on;

for i=1:length(dteta_inicial_set)
        
       teta_inicial=teta_inicial_set(i);
       dteta_inicial=dteta_inicial_set(i);
       
        sim('sim6');
        
        teta=var_est(:,1);
        dteta=var_est(:,2);
        
        figure(1);
        p(i)=plot(teta,dteta);
        hold on;
        
end

figure(1);
xlabel('\theta'); ylabel('$\dot \theta$','interpreter','latex');
title('Espaço de estados para \beta=0 Nms/rad');
lg=legend([p(1) p(2) p(3) p(4)],'(\pi/2,\pi/2)',...
    '(-\pi/3,\pi/3)',...
    '(-\pi/4,-\pi/4)','(\pi/6,-\pi/6)','Orientation','horizontal');
set(gca,'fontsize',12);
xlim([-2 2]); ylim([-14 14]);
set(lg,'fontsize',9);


%%
close all

beta=0.1;
teta_inicial_set=[pi/2 -pi/3 -pi/4 pi/6];
dteta_inicial_set=[pi/2 pi/3 -pi/4 -pi/6]; 

x1=linspace(-2,2,25);
x2=linspace(-10,10,25);

[x1,x2] = meshgrid(x1,x2);
dx1=x2;
dx2=((g*(m*l+(1/2)*M*L)-k)/J)*x1 -(beta/J)*x2;

figure(1);
quiver(x1,x2,dx1,dx2);
hold on;

for i=1:length(dteta_inicial_set)
        
       teta_inicial=teta_inicial_set(i);
       dteta_inicial=dteta_inicial_set(i);
       
        sim('sim6');
        
        teta=var_est(:,1);
        dteta=var_est(:,2);
        
        figure(1);
        p(i)=plot(teta,dteta);
        hold on;
        
end

figure(1);
xlabel('\theta'); ylabel('$\dot \theta$','interpreter','latex');
title('Espaço de estados para \beta=0.1 Nms/rad');
set(gca,'fontsize',12);
xlim([-2 2]); ylim([-10 10]);
lg=legend([p(1) p(2) p(3) p(4)],'(\pi/2,\pi/2)','(-\pi/3,\pi/3)',...
    '(-\pi/4,-\pi/4)','(\pi/6,-\pi/6)','Orientation','horizontal');
set(lg,'fontsize',9)


%%
close all 

beta=1;
teta_inicial_set=[pi/2 -pi/3 -pi/4 pi/6];
dteta_inicial_set=[pi/2 pi/3 -pi/4 -pi/6]; 

x1=linspace(-2,2,25);
x2=linspace(-5,5,25);

[x1,x2] = meshgrid(x1,x2);
dx1=x2;
dx2=((g*(m*l+(1/2)*M*L)-k)/J)*x1 -(beta/J)*x2;

figure(1);
quiver(x1,x2,dx1,dx2);
hold on;

for i=1:length(dteta_inicial_set)
        
       teta_inicial=teta_inicial_set(i);
       dteta_inicial=dteta_inicial_set(i);
       
        sim('sim6');
        
        teta=var_est(:,1);
        dteta=var_est(:,2);
        
        figure(1);
        p(i)=plot(teta,dteta);
        hold on;
        
end

figure(1);
xlabel('\theta'); ylabel('$\dot \theta$','interpreter','latex');
title('Espaço de estados para \beta=1 Nms/rad');
set(gca,'fontsize',12);
xlim([-2 2]);
lg=legend([p(1) p(2) p(3) p(4)],'(\pi/2,\pi/2)','(-\pi/3,\pi/3)',...
    '(-\pi/4,-\pi/4)','(\pi/6,-\pi/6)','Orientation','horizontal');
set(lg,'fontsize',9)


%%
L=0.5;
M=0.15;
l=0.4;
m=0.2;
k=3;
g=9.8;
J=(m*l^2)+(M/3)*L^2;

for beta=[0 0.1 1]
A=[0 1; ((g*(m*l+(1/2)*M*L)-k)/J) -(beta/J)];

Valores_proprios=eig(A);
[Vectores_proprios,~] = eig(A);
display(beta);
display(Valores_proprios);
display(Vectores_proprios);

end
%%
% * Para $\beta=0$ Nms/rad, os valores próprios são imaginários puros e
% os gráficos obtidos são circunferências centradas na origem cujo raio 
% depende apenas da amplitude das condições iniciais.
% Esta dinâmica ocorre quando os pólos do sistema estão situados
% no eixo imaginário e, uma vez que pólos=Valores próprios da matriz
% A, confirma-se os resultados obtidos.
%
% * Para $\beta=0.1$ Nms/rad, os gráficos obtidos são espiras que se iniciam
% no ponto correspondente às condições iniciais e terminam na origem.
% Esta dinâmica ocorre quando os pólos do sistema estão situados no semi-plano
% complexo esquerdo, verificado pela parte real dos valores próprios.
%
% * Para $\beta=1$ Nms/rad, todas as curvas têm início nas suas 
% condições iniciais e evoluem até chegar a um ponto em que se 
% deslocam linearmente para a origem. Esta dinâmica ocorre quando os pólos
% do sistema estão situados no eixo real do semi-plano complexo esquerdo,
% como confirmado pelos valores próprios obtidos.
%% Pergunta 8
%%
clear
close all

L=0.5;
M=0.15;
l=0.4;
m=0.2;
k=3;
beta=0.1;
g=9.8;
J=(m*l^2)+(M/3)*L^2;
u=[0 0];

beta=1;
teta_inicial_set=[-0.0489 0.4415];
dteta_inicial_set=[0.9900 -0.8973]; 

for i=1:length(dteta_inicial_set)
        
       teta_inicial=teta_inicial_set(i);
       dteta_inicial=dteta_inicial_set(i);
       
        sim('sim6');
        
        teta=var_est(:,1);
        dteta=var_est(:,2);
        
        figure(1);
        plot(teta,dteta,'LineWidth',1);
        hold on;
end

figure(1);
xlabel('\theta'); ylabel('$\dot \theta$','interpreter','latex');
title('Espaço de estados');
set(gca,'fontsize',12);
legend(sprintf('(%.3f,%.3f)',teta_inicial_set(1),dteta_inicial_set(1)),...
    sprintf('(%.3f,%.3f)',teta_inicial_set(2),dteta_inicial_set(2)));
xlim([-2 2]);

%%
% A escolha dos dois conjuntos de condições iniciais é indicada no
% documento 'QuestoesTeoricas-Lab3-Grupo16.pdf'. O gráfico obtido serve de
% confirmação dessa escolha.
%% Pergunta 9
%
% Para esta questão criaram-se três funções, a primeira 'freq_to_bpm'
% apenas converte a frequência de oscilação obtida em BPM. 
%
% A segunda, denominada 'calc_media_BPM' é utilizada para calcular uma
% média das frequências medidas entre os vários picos do sinal, de forma a
% diminuir o erro.
%
% A terceira, denominada 'parametros_estimados' é a utilizada para a 
% estimativa de m, l1 (comprimento de l que permite obter no metrónomo a 
% cadência de 53 BPM) e l2 (cadência de 141 BPM).
%
% A descrição da estratégia de dimensionamento é indicada no
% documento 'QuestoesTeoricas-Lab3-Grupo16.pdf'. No entanto, é importante 
% referir que foi feita a aproximação $w_n\approx w_a$, pois $w_a=w_n\sqrt{1-\zeta^2}$ 
% e para valores de $\beta$ baixos $\zeta\approx 0$.
%%
type('freq_to_bpm.m');
%%
type('calc_media_BPM');
%%
type('parametros_estimados.m');
%%
clear
close all

L=0.25;
M=0.1;
k=0.35;
g=9.8;
beta=0.001;

m_set=linspace(0,0.1,200); %valores de m
l_set=linspace(0.05,0.25,200); %valores de l

for i=1:length(m_set)
    m=m_set(i);
    for j=1:length(l_set)
        l=l_set(j);
        
        J=(m*l^2)+(M/3)*L^2;
        
        if (k-g*(m*l+(1/2)*M*L))/J<0 
            BPM(i,j)=NaN;
            continue;
        end
        %Cálculo da frequência natural das oscilações amortecidas
        wn=sqrt((k-g*(m*l+(1/2)*M*L))/J);
        %Cálculo da frequência em BPM
        BPM(i,j)=freq_to_bpm(wn);
    end
end

%Variação da frequêcia com a massa e o comprimento l

figure(1);
surfc(m_set,l_set,BPM);
shading interp;
view(130, 30);
ylabel('l [m]'); xlabel('m [Kg]'); zlabel('Frequência [BPM]');

%Cálculos de m,l1 e l2
[BPM1,ind_r,l1,m_est]=parametros_estimados(BPM,53,m_set,l_set);
[BPM2,~,l2,~]=parametros_estimados(BPM(ind_r,:),141,m_set,l_set);

% (m,l1)
dteta_inicial=0;
teta_inicial=pi/4;
u=[0 0];
m=m_est;
l=l1;
J=(m*l^2)+(M/3)*L^2;
sim('sim6',25);

teta=var_est(:,1);
[~,locs] = findpeaks(teta);
ind_inicial=1;
media_BPM1=calc_media_BPM(t,locs,ind_inicial);

%Envolvente
wn=sqrt((k-g*(m*l+(1/2)*M*L))/J);
zeta=beta/(2*J*wn);

env=(pi/4)*exp(-zeta*wn*t);

%Plot para 53 BPM
figure(2);
plot(t,teta,t,env,'r',t,-env,'r');
xlabel('t [s]'); ylabel('\theta');
title('Posição em função do tempo '); set(gca,'fontsize',12);
legend(sprintf('\\theta(t) - %.2f BPM',media_BPM1),'Envolvente Teórica');

% (m,l2)
l=l2;
J=(m*l^2)+(M/3)*L^2;
sim('sim6',25);

teta=var_est(:,1);
[~,locs] = findpeaks(teta);
ind_inicial=1;
media_BPM2=calc_media_BPM(t,locs,ind_inicial);


%Envolvente
wn=sqrt((k-g*(m*l+(1/2)*M*L))/J);
zeta=beta/(2*J*wn);

env=(pi/4)*exp(-zeta*wn*t);

%Plot para 141 BPM
figure(3);
plot(t,teta,t,env,'r',t,-env,'r');
xlabel('t [s]'); ylabel('\theta');
title('Posição em função do tempo '); set(gca,'fontsize',12);
legend(sprintf('\\theta(t) - %.2f BPM',media_BPM2),'Envolvente Teórica');

%Dimensionamento

fprintf('m estimado: %.4f\n',m_est);
fprintf('l1 estimado: %.4f\n',l1);
fprintf('Frequência em BPM obtida: %.2f\n',media_BPM1);
fprintf('l2 estimado: %.4f\n',l2);
fprintf('Frequência em BPM obtida: %.2f\n',media_BPM2);

%%
% A envolvente obtida adequa-se bem aos gráficos obtidos. Obteve-se,
% aproximadamente, a frequência pretendida para as duas cadências o que confirma
% a validade da estratégia utilizada.
%% Pergunta 10
% Para esta questão foi desenvolvido o seguinte esquema em Simulink para 
% simular o modelo não linear do metrónomo:
%%
open('sim10');
%%
% Em que o bloco 'MATLAB Function' apresenta o seguinte código:
%
%%
type('fcn.m');
%%
% Foram criadas duas funções para se utilizar na função fminsearch, de
% forma a encontrar-se o parâmetro l que diminui o erro=BPM pretendido-BPM
% simulado, sem ter de se utilizar uma procura extensiva.
%
% A função que obtém o comprimento l que permite ter no metrónomo a 
% cadência de 53 BPM é:
%%
type('calc_erro_l1.m');
%%
% A função que obtém o comprimento l que permite ter no metrónomo a 
% cadência de 141 BPM é:
%%
type('calc_erro_l2.m');
%%
clear
close all

L=0.25;
M=0.1;
k=0.35;
g=9.8;
beta=0.001;
dteta_inicial=0;
teta_inicial=pi/4;
T=0;
m=0.0799;
l=0.2289;
sim('sim10',40);

[~,locs] = findpeaks(teta);
%inicia-se a média no indíce 10 para dar tempo ao transitório de se
%extinguir
ind_inicial=10;
media_BPM1=calc_media_BPM(t,locs,ind_inicial);
desvio_freq_1=abs(53-media_BPM1);
display(desvio_freq_1)

% (m,l2)
l=0.0952;
sim('sim10',40);

[~,locs] = findpeaks(teta);
ind_inicial=10;
media_BPM2=calc_media_BPM(t,locs,ind_inicial);
desvio_freq_2=abs(141-media_BPM2);
display(desvio_freq_2)

% Refinamento do dimensionamento

%l1
l1=0.2289;
xo=l1;
fun=@calc_erro_l1;
[l1_est,erro]=fminsearch(fun,xo);
display(erro)
display(l1_est)

%l2
l2=0.0952;
xo=l2;
fun=@calc_erro_l2;
[l2_est,erro]=fminsearch(fun,xo);
display(erro)
display(l2_est)

%Plot 

for l=[l1_est l2_est]
    sim('sim10',40);
    
    [~,locs] = findpeaks(teta);
    ind_inicial=10;
    media_BPM=calc_media_BPM(t,locs,ind_inicial);
    
    figure;
    plot(t,teta);
    xlabel('t [s]'); ylabel('\theta');
    title('Posição em função do tempo '); set(gca,'fontsize',12);
    legend(sprintf('\\theta(t) - %.2f BPM',media_BPM));
end

%% Pergunta 11
% Nesta questão foi modificado o diagrama anterior, por forma a simular a
% existência de um mecanismo de relojoaria no metrónomo que impulsiona
% durante breves instantes o pêndulo quando este passa na vertical.
%
% Para este efeito, utilizou-se um bloco 'Switch' para que se
% $| \theta |<int$, se aplique um binário externo cujo o valor é 7 vezes
% superior à força de atrito aplicada, de forma a contrariar a mesma e a
% evitar o decaimento natural para zero da amplitude das oscilações.
%%
open('sim11');
%%
close all
clear

L=0.25;
M=0.1;
k=0.35;
g=9.8;
beta=0.001;
dteta_inicial=0;
teta_inicial=pi/4;
int=0.1;
i=1;

m=0.0799;
%Parâmetros estimados na alínea 10
l1=0.2291;
l2=0.0951;

for l=[l1 l2]
sim('sim11',40);

[~,locs] = findpeaks(teta);
ind_inicial=10;
BPM(i)=calc_media_BPM(t,locs,ind_inicial);

figure;
plot(t,teta);
xlabel('t [s]'); ylabel('\theta');
title('Posição em função do tempo '); set(gca,'fontsize',12);
legend(sprintf('\\theta(t) - %.2f BPM',BPM(i)));
figure;
plot(t,T);
xlabel('t [s]'); ylabel('T');
title('Binário externo aplicado'); set(gca,'fontsize',12);

i=i+1;
end
%%
% Quando se aplica o binário externo verifica-se uma mudança na frequência
% de oscilação relativamente à pretendida, principalmente para a frequência
% mais baixa. Para acertar teria de se considerar o binário externo no
% dimensionamento de l.
%% Pergunta 12

%%
clear
close all

L=0.25;
M=0.1;
k=0.35;
g=9.8;
beta=0.001;
dteta_inicial=0;
teta_inicial=pi/4;

m=0.0799;
%Parâmetros estimados na questão 9
l1=0.2289;
l2=0.0952;

for l=[l1 l2]
    
J=(m*l^2)+(M/3)*L^2;
G=1/(k-g*(m*l+(1/2)*M*L));
wn=sqrt((k-g*(m*l+(1/2)*M*L))/J);
zeta=beta/(2*J*wn);

H=tf(G*wn^2,[1 2*zeta*wn wn^2]);
w = linspace(10e-2,10e2,10e5);

figure(1);
h=bodeplot(H,w);
hold on;
end

p = getoptions(h);
p.YLim{1}=[-40 60];
setoptions(h,p);
figure(1);
legend('53 BPM','141 BPM');
%%
% Os diagramas de bode obtidos para as duas posições da massa são
% semelhantes, as principais diferenças prendem-se com o facto do "pico" da
% amplitude ocorrer na frequência de oscilação 53 BPM para l=0.2289 e em 141 BPM para
% l=0.0952 e que para a menor frequência obtém-se um maior ganho de
% amplitude. 
%
% O dispositivo que poderia fornecer a este sistema mecânico o tipo de entrada
% subjacente ao diagrama de Bode é um filtro passa-baixo com um pólo duplo,
% pois a partir da frequência de corte a amplitude do diagrama diminui 40
% dB/dec.

%% Pergunta 13
% Para esta questão foi criado um diagrama de blocos em Simulink, onde se
% aplica um binário externo sinusoidal com frequência ajustável e à saída
% do bloco da função de transferência do sistema linear temos o valor de
% $\theta$.
%%
open('sim13');
%%
clear
close all

L=0.25;
M=0.1;
k=0.35;
g=9.8;
beta=0.001;
dteta_inicial=0;
teta_inicial=pi/4;
m=0.0799;
l=0.2289;
i=1;

J=(m*l^2)+(M/3)*L^2;
G=1/(k-g*(m*l+(1/2)*M*L));
wn=sqrt((k-g*(m*l+(1/2)*M*L))/J);
zeta=beta/(2*J*wn);

%testa-se para as frequências angulares entre 2 e 3 rad/s
w_teste_set=2:0.01:3; 

for i=1:length(w_teste_set)
    
w_teste=w_teste_set(i);
sim('sim13',50);

%Obtém-se o valor máximo de cada gráfico obtido
amp(i)=max(teta);

end

%Encontra-se a frequência para a qual teta apresenta maior amplitude
[~,ind]=max(amp);

%Obtém-se wn
w_esc=w_teste_set(ind);

%Calcula-se a massa com o valor de wn
m_calc=(k-J*w_esc^2-g*(1/2)*M*L)/(g*l);

fprintf('massa real: %.4f \nmassa estimada: %.4f\n',m,m_calc);

%%
% A descrição da estratégia da medição da massa encontra-se no documento 
% 'QuestoesTeoricas-Lab3-Grupo16.pdf'.

##### SOURCE END #####
--></body></html>
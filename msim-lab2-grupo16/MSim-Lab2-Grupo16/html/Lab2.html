
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>2&ordm; Laborat&oacute;rio de Modela&ccedil;&atilde;o e Simula&ccedil;&atilde;o 2019/20</title><meta name="generator" content="MATLAB 8.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-04-28"><meta name="DC.source" content="Lab2.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>2&ordm; Laborat&oacute;rio de Modela&ccedil;&atilde;o e Simula&ccedil;&atilde;o 2019/20</h1><!--introduction--><p>Optimiza&ccedil;&atilde;o do servomecanismo de um disco r&iacute;gido</p><p>Alice Rosa, n&ordm; 90007</p><p>Beatriz Pereira, n&ordm; 90029</p><p>Grupo 16, Turno 3&ordf; feira &agrave;s 9h00</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Pergunta 2</a></li><li><a href="#6">Pergunta 3</a></li><li><a href="#11">Pergunta 7</a></li><li><a href="#17">Pergunta 8</a></li><li><a href="#20">Pergunta 9</a></li><li><a href="#25">Pergunta 10</a></li><li><a href="#29">Pergunta 11</a></li><li><a href="#39">Pergunta 12</a></li><li><a href="#43">Pergunta 13</a></li></ul></div><h2>Pergunta 2<a name="1"></a></h2><p>Foi criada a seguinte fun&ccedil;&atilde;o, "imp_prot", para a gera&ccedil;&atilde;o do impulso prot&oacute;tipo.</p><pre class="codeinput">type(<span class="string">'imp_prot.m'</span>);
</pre><pre class="codeoutput">
function p_beta=imp_prot(t,beta)

ind= t&lt;=-(beta/2)-(1/2);
part0=zeros(1,length(t(ind)));

ind= t&gt;-(beta/2)-(1/2) &amp; t&lt;=-(1/2);
part1 = (1/2)*(((4/beta^2).*(t(ind)+(1/2))+(2/beta)).*(t(ind)+(1/2)+(beta/2)));

ind= t&gt;-(1/2) &amp; t&lt;=(beta/2)-(1/2);
part2= 1-((1/2)*((-(4/beta^2).*(t(ind)+(1/2))+(2/beta)).*((beta/2)-(t(ind)+(1/2)))));

ind= t&gt;(beta/2)-(1/2) &amp; t&lt;=-(beta/2)+(1/2);
part3=ones(1,length(t(ind)));

ind= t&gt;-(beta/2)+(1/2) &amp; t&lt;=(1/2);
part4= 1-((1/2)*(((4/beta^2).*(t(ind)-(1/2))+(2/beta)).*(t(ind)-(1/2)+(beta/2))));

ind= t&gt;(1/2) &amp; t&lt;=(beta/2)+(1/2);
part5=(1/2)*((-(4/beta^2).*(t(ind)-(1/2))+(2/beta)).*((beta/2)-(t(ind)-(1/2))));

ind= t&gt;(beta/2)+(1/2);
part6=zeros(1,length(t(ind)));

p_beta=[part0 part1 part2 part3 part4 part5 part6];

end
</pre><p>Nesta fun&ccedil;&atilde;o, deu-se uso &agrave;s express&otilde;es anal&iacute;ticas deduzidas na al&iacute;nea 1, obtendo-se para cada intervalo adequado o valor de <img src="Lab2_eq02703186052152770462.png" alt="$p_\beta(t)$">. No final, concatenaram-se todas as partes para se obter o impulso prot&oacute;tipo.</p><pre class="codeinput">clear
t=-1:0.01:1;
beta_set=[0 0.2 0.7 1];

<span class="keyword">for</span> i=1:length(beta_set)
 beta=beta_set(i);
 pbeta=imp_prot(t,beta);
 figure(1);
 plot(t,pbeta);
 hold <span class="string">on</span>;
<span class="keyword">end</span>

xlabel(<span class="string">'t [s]'</span>);
ylabel(<span class="string">'$p_\beta(t)$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
title(<span class="string">'Impulso Prot&oacute;tipo'</span>);
set(gca,<span class="string">'Fontsize'</span>,14);
lg=legend(sprintf(<span class="string">'\\beta=%.1f'</span>,beta_set(1)),sprintf(<span class="string">'\\beta=%.1f'</span>,beta_set(2)),<span class="keyword">...</span>
    sprintf(<span class="string">'\\beta=%.1f'</span>,beta_set(3)),sprintf(<span class="string">'\\beta=%.1f'</span>,beta_set(4)));
set(lg,<span class="string">'Fontsize'</span>,10);
</pre><img vspace="5" hspace="5" src="Lab2_01.png" alt=""> <p>Geraram-se 4 impulsos prot&oacute;tipos, para diferentes <img src="Lab2_eq17331442575217596290.png" alt="$\beta$">, de forma a evidenciar a influ&ecirc;ncia deste na forma do impulso.</p><p>Como se pode verificar, o par&acirc;metro <img src="Lab2_eq17331442575217596290.png" alt="$\beta$"> influencia a dura&ccedil;&atilde;o total do impulso e a dura&ccedil;&atilde;o dos flancos acendentes e descentes do mesmo.</p><div><ul><li>Para <img src="Lab2_eq01943888942785439951.png" alt="$\beta=0$">, o impulso gerado &eacute; rectangular, ou seja, o tempo de descida e subida s&atilde;o nulos.</li><li>Para <img src="Lab2_eq17135930029550579103.png" alt="$0<\beta<1$">, verifica-se o aumento gradual dos tempos de subida e descida com o aumento de <img src="Lab2_eq17331442575217596290.png" alt="$\beta$">.</li><li>Para <img src="Lab2_eq07813526719646221217.png" alt="$\beta=1$">, a tempo de subida &eacute; igual ao tempo de descida e a soma dos dois corresponde &agrave; dura&ccedil;&atilde;o total do impulso.</li></ul></div><h2>Pergunta 3<a name="6"></a></h2><p>Foi criada a seguinte fun&ccedil;&atilde;o, "sinal_entrada", para a gera&ccedil;&atilde;o do sinal de controlo, <img src="Lab2_eq17794740544861059683.png" alt="$u(t)$">.</p><pre class="codeinput">type(<span class="string">'sinal_entrada.m'</span>);
</pre><pre class="codeoutput">
function [u,t]=sinal_entrada(T,alpha,beta,U1,U2,n1,n2)

    T1=T/(1+alpha);
    T2=alpha*T1;
    t1=linspace(-(1/2)-(beta/2),(1/2)+(beta/2),n1);
    t2=linspace(-(1/2)-(beta/2),(1/2)+(beta/2),n2);
    
    u1=-U1*imp_prot(t1,beta); %Mudar a amplitude do sinal
    t_1=(t1*(T1/(1+beta)))+(T1/2); %Expans&atilde;o e deslocamento do sinal do tempo
    
    u2=U2*imp_prot(t2,beta); 
    t_2=(t2*(T2/(1+beta))); %Expans&atilde;o do sinal do tempo
    dif=t_1(n1)-t_2(1); %Dist&acirc;ncia entre o final do 1&ordm; impulso e inicio do segundo
    t__2=t_2+dif; %Deslocamento do segundo impulso no tempo
    
    u=[u1 u2]; %Concatena&ccedil;&atilde;o dos dois impulsos 
    t=[t_1 t__2];
end
</pre><p>Nesta fun&ccedil;&atilde;o, realizaram-se transforma&ccedil;&otilde;es na amplitude e no tempo a partir do impulso prot&oacute;tipo. O primeiro impulso &eacute; multiplicado pela amplitude U1, expandido no tempo de acordo com o factor <img src="Lab2_eq10433426664288541706.png" alt="$\mu_1=T1/(1+\beta)$"> e avan&ccedil;ado <img src="Lab2_eq10321591261416838977.png" alt="$T_1/2$">. As mesmas transforma&ccedil;&otilde;es de amplitude e de expans&atilde;o foram realizadas para o segundo impulso com a amplitude U2 e per&iacute;odo T2, este foi avan&ccedil;ado no tempo de forma ao seu in&iacute;cio corresponder ao final do primeiro impulso.</p><pre class="codeinput">clear
close <span class="string">all</span>

T=5;
alpha_set=[0.5 1 1.5];
beta=0.5;
U1=1;
U2=1;
n1=400;
n2=400;

<span class="keyword">for</span> i=1:length(alpha_set)
 alpha=alpha_set(i);
 [u,t]=sinal_entrada(T,alpha,beta,U1,U2,n1,n2);
 figure(1);
 plot(t,u);
 hold <span class="string">on</span>;
<span class="keyword">end</span>

xlim([t(1) t(length(t))]);
xlabel(<span class="string">'t [s]'</span>);
ylabel(<span class="string">'$u(t)$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
title(<span class="string">'Sinal de Controlo'</span>);
set(gca,<span class="string">'Fontsize'</span>,14);
grid <span class="string">on</span>;
legend(sprintf(<span class="string">'\\alpha=%.1f'</span>,alpha_set(1)),sprintf(<span class="string">'\\alpha=%.1f'</span>,alpha_set(2)),<span class="keyword">...</span>
    sprintf(<span class="string">'\\alpha=%.1f'</span>,alpha_set(3)),<span class="string">'Location'</span>,<span class="string">'northwest'</span>);
</pre><img vspace="5" hspace="5" src="Lab2_02.png" alt=""> <p>Geraram-se 3 sinais de controlo, para diferentes valores de <img src="Lab2_eq14221827199139923399.png" alt="$\alpha$">, de forma a evidenciar a influ&ecirc;ncia deste na forma do sinal. Como se pode verificar, o par&acirc;metro <img src="Lab2_eq14221827199139923399.png" alt="$\alpha$"> influencia os par&acirc;metros T1 e T2 do sinal.</p><div><ul><li>Para <img src="Lab2_eq08047647481443586286.png" alt="$0<\alpha<1$">, T1&gt;T2, ou seja, a dura&ccedil;&atilde;o do primeiro impulso &eacute; superior &agrave; do segundo.</li><li>Para <img src="Lab2_eq08959333113985291603.png" alt="$\alpha&gt;1$">, T1&lt;T2.</li></ul></div><h2>Pergunta 7<a name="11"></a></h2><p>Para esta quest&atilde;o, realizou-se a simula&ccedil;&atilde;o do sistema em malha aberta, onde, a partir das express&otilde;es obtidas na al&iacute;nea 6, gera-se o sinal de controlo <img src="Lab2_eq17794740544861059683.png" alt="$u(t)$"> e obt&eacute;m-se os valores da posi&ccedil;&atilde;o e velocidade da cabe&ccedil;a sobre o disco, resolvendo a seguinte equa&ccedil;&atilde;o diferencial:</p><p><img src="Lab2_eq08566114918980279488.png" alt="$\ddot y(t)=u-b\dot y$"></p><p>Onde b &eacute; uma constante associada a um termo que modela o efeito de atrito.</p><p>Para obter os valores da posi&ccedil;&atilde;o e velocidade utilizou-se o seguinte diagrama de blocos desenvolvido no SIMULINK:</p><pre class="codeinput">open(<span class="string">'sim7'</span>);
</pre><img vspace="5" hspace="5" src="Lab2_03.png" alt=""> <pre class="codeinput">clear
close <span class="string">all</span>

alpha=[0.5 1 1.5];
beta=[0.5 0.5 0.5];
n1=400;
n2=400;
y_inicial=1;
dy_inicial=0;
b=0;

<span class="keyword">for</span> i=1:length(alpha);

    <span class="keyword">if</span> alpha(i)&gt;0 &amp;&amp; alpha(i)&lt;=1
        T=sqrt((2/alpha(i))*(1+beta(i))*(1+alpha(i)));
    <span class="keyword">elseif</span> alpha(i)&gt;1
        T=sqrt(2*(1+beta(i))*(1+alpha(i)));
    <span class="keyword">end</span>

    T1=T/(1+alpha(i));
    U1=(2*(1+beta(i)))/(T1^2*(1+alpha(i)));
    U2=U1/alpha(i);

    [u,t]=sinal_entrada(T,alpha(i),beta(i),U1,U2,n1,n2);
    figure(1);
    plot(t,u);
    hold <span class="string">on</span>;

    sinal.time=t';
    sinal.signals.values=u';
    sinal.signals.dimensions=1;
    sim(<span class="string">'sim7'</span>);

    figure(2);
    plot(tout,dy);
    hold <span class="string">on</span>;

    figure(3);
    plot(tout,y);
    hold <span class="string">on</span>;

    figure(4);
    plot(y,dy);
    hold <span class="string">on</span>;

<span class="keyword">end</span>

figure(1);
xlabel(<span class="string">'t [s]'</span>);
ylabel(<span class="string">'$u(t)$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
title(<span class="string">'Sinais de Controlo'</span>);
grid <span class="string">on</span>;
set(gca,<span class="string">'fontsize'</span>,12);
legend(sprintf(<span class="string">'\\alpha=%.1f \\beta=%.1f'</span>,alpha(1),beta(1)),<span class="keyword">...</span>
    sprintf(<span class="string">'\\alpha=%.1f \\beta=%.1f'</span>,alpha(2),beta(2)),<span class="keyword">...</span>
    sprintf(<span class="string">'\\alpha=%.1f \\beta=%.1f'</span>,alpha(3),beta(3)),<span class="string">'Location'</span>,<span class="string">'northwest'</span>);

figure(2);
xlabel(<span class="string">'t [s]'</span>);
ylabel(<span class="string">'$\dot y(t)$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
title(<span class="string">'Velocidade'</span>);
grid <span class="string">on</span>;
set(gca,<span class="string">'fontsize'</span>,12);
legend(sprintf(<span class="string">'\\alpha=%.1f \\beta=%.1f'</span>,alpha(1),beta(1)),<span class="keyword">...</span>
    sprintf(<span class="string">'\\alpha=%.1f \\beta=%.1f'</span>,alpha(2),beta(2)),<span class="keyword">...</span>
    sprintf(<span class="string">'\\alpha=%.1f \\beta=%.1f'</span>,alpha(3),beta(3)),<span class="string">'Location'</span>,<span class="string">'southeast'</span>);

figure(3);
ylim([0 1]);
xlabel(<span class="string">'t [s]'</span>);
ylabel(<span class="string">'y(t)'</span>);
title(<span class="string">'Posi&ccedil;&atilde;o'</span>);
grid <span class="string">on</span>;
set(gca,<span class="string">'fontsize'</span>,12);
legend(sprintf(<span class="string">'\\alpha=%.1f \\beta=%.1f'</span>,alpha(1),beta(1)),<span class="keyword">...</span>
    sprintf(<span class="string">'\\alpha=%.1f \\beta=%.1f'</span>,alpha(2),beta(2)),<span class="keyword">...</span>
    sprintf(<span class="string">'\\alpha=%.1f \\beta=%.1f'</span>,alpha(3),beta(3)));

figure(4);
xlabel(<span class="string">'y(t)'</span>);
ylabel(<span class="string">'$\dot y(t)$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
title(<span class="string">'Curvas de Comuta&ccedil;&atilde;o'</span>);
grid <span class="string">on</span>;
set(gca,<span class="string">'fontsize'</span>,12);
legend(sprintf(<span class="string">'\\alpha=%.1f \\beta=%.1f'</span>,alpha(1),beta(1)),<span class="keyword">...</span>
    sprintf(<span class="string">'\\alpha=%.1f \\beta=%.1f'</span>,alpha(2),beta(2)),<span class="keyword">...</span>
    sprintf(<span class="string">'\\alpha=%.1f \\beta=%.1f'</span>,alpha(3),beta(3)));
</pre><img vspace="5" hspace="5" src="Lab2_04.png" alt=""> <img vspace="5" hspace="5" src="Lab2_05.png" alt=""> <img vspace="5" hspace="5" src="Lab2_06.png" alt=""> <img vspace="5" hspace="5" src="Lab2_07.png" alt=""> <p>Na figura 1, podemos observar os sinais de controlo obtidos a partir dos par&acirc;metros deduzidos, tendo em aten&ccedil;&atilde;o que T(<img src="Lab2_eq14221827199139923399.png" alt="$\alpha$">=0.5)= 3 s, T(<img src="Lab2_eq14221827199139923399.png" alt="$\alpha$">=1)= 2.7 e T(<img src="Lab2_eq14221827199139923399.png" alt="$\alpha$">=1.5)=2.48 s, aproximadamente.</p><p>A partir das figuras 2,3 e 4, verific&aacute;mos a validade das express&otilde;es anal&iacute;ticas obtidas na al&iacute;nea 6, uma vez que para os 3 pares de <img src="Lab2_eq12210984554722879652.png" alt="$\alpha,\beta$"> obtemos as configura&ccedil;&otilde;es finais desejadas, y(T)=0 e <img src="Lab2_eq01703926406973965823.png" alt="$\dot y(T)=0$">.</p><p>Tamb&eacute;m podemos verificar que, tal como foi deduzido, o valor de <img src="Lab2_eq14221827199139923399.png" alt="$\alpha$"> que minimiza T &eacute; 1.</p><p>De seguida, obt&eacute;m-se os mesmos gr&aacute;ficos, mas agora com o sistema perturbado com b=0.025.</p><pre class="codeinput"> close <span class="string">all</span>

 b=0.025;

<span class="keyword">for</span> i=1:length(alpha);

    <span class="keyword">if</span> alpha(i)&gt;0 &amp;&amp; alpha(i)&lt;=1
        T=sqrt((2/alpha(i))*(1+beta(i))*(1+alpha(i)));
    <span class="keyword">elseif</span> alpha(i)&gt;1
        T=sqrt(2*(1+beta(i))*(1+alpha(i)));
    <span class="keyword">end</span>

    T1=T/(1+alpha(i));
    U1=(2*(1+beta(i)))/(T1^2*(1+alpha(i)));
    U2=U1/alpha(i);

    [u,t]=sinal_entrada(T,alpha(i),beta(i),U1,U2,n1,n2);

    sinal.time=t';
    sinal.signals.values=u';
    sinal.signals.dimensions=1;
    sim(<span class="string">'sim7'</span>);

    figure(1);
    plot(tout,dy);
    hold <span class="string">on</span>;

    figure(2);
    plot(tout,y);
    hold <span class="string">on</span>;

    figure(3);
    plot(y,dy);
    hold <span class="string">on</span>;

<span class="keyword">end</span>

figure(1);
xlabel(<span class="string">'t [s]'</span>);
ylabel(<span class="string">'$\dot y(t)$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
title(<span class="string">'Velocidade'</span>);
grid <span class="string">on</span>;
set(gca,<span class="string">'fontsize'</span>,12);
legend(sprintf(<span class="string">'\\alpha=%.1f \\beta=%.1f'</span>,alpha(1),beta(1)),<span class="keyword">...</span>
    sprintf(<span class="string">'\\alpha=%.1f \\beta=%.1f'</span>,alpha(2),beta(2)),<span class="keyword">...</span>
    sprintf(<span class="string">'\\alpha=%.1f \\beta=%.1f'</span>,alpha(3),beta(3)),<span class="string">'Location'</span>,<span class="string">'southeast'</span>);

figure(2);
ylim([0 1]);
xlabel(<span class="string">'t [s]'</span>);
ylabel(<span class="string">'y(t)'</span>);
title(<span class="string">'Posi&ccedil;&atilde;o'</span>);
grid <span class="string">on</span>;
set(gca,<span class="string">'fontsize'</span>,12);
legend(sprintf(<span class="string">'\\alpha=%.1f \\beta=%.1f'</span>,alpha(1),beta(1)),<span class="keyword">...</span>
    sprintf(<span class="string">'\\alpha=%.1f \\beta=%.1f'</span>,alpha(2),beta(2)),<span class="keyword">...</span>
    sprintf(<span class="string">'\\alpha=%.1f \\beta=%.1f'</span>,alpha(3),beta(3)));

figure(3);
xlabel(<span class="string">'y(t)'</span>);
ylabel(<span class="string">'$\dot y(t)$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
title(<span class="string">'Curvas de Comuta&ccedil;&atilde;o'</span>);
grid <span class="string">on</span>;
set(gca,<span class="string">'fontsize'</span>,12);
legend(sprintf(<span class="string">'\\alpha=%.1f \\beta=%.1f'</span>,alpha(1),beta(1)),<span class="keyword">...</span>
    sprintf(<span class="string">'\\alpha=%.1f \\beta=%.1f'</span>,alpha(2),beta(2)),<span class="keyword">...</span>
    sprintf(<span class="string">'\\alpha=%.1f \\beta=%.1f'</span>,alpha(3),beta(3)));
</pre><img vspace="5" hspace="5" src="Lab2_08.png" alt=""> <img vspace="5" hspace="5" src="Lab2_09.png" alt=""> <img vspace="5" hspace="5" src="Lab2_10.png" alt=""> <p>Nesta situa&ccedil;&atilde;o, verifica-se que o estudo feito teoricamente j&aacute; n&atilde;o &eacute; v&aacute;lido. O sistema n&atilde;o &eacute; conduzido para a configura&ccedil;&atilde;o final desejada, visto que <img src="Lab2_eq12167662401921723859.png" alt="$y(T) \neq 0$"> e <img src="Lab2_eq17880414841038771918.png" alt="$\dot y(T) \neq 0$">. Desta forma, como se pode observar nas figuras da posi&ccedil;&atilde;o e velocidade, a cabe&ccedil;a magn&eacute;tica permanece em movimento, sem atingir o equ&iacute;librio.</p><p>Pode-se concluir que o sistema em malha aberta &eacute; bastante sens&iacute;vel a perturba&ccedil;&otilde;es. Para contornar este problema recorre-se a um sistema em malha fechada, pois este altera o sinal de controlo tendo em conta a evolu&ccedil;&atilde;o do sistema.</p><h2>Pergunta 8<a name="17"></a></h2><pre class="codeinput">clear
close <span class="string">all</span>

y=-1:0.05:1;
dy=-1:0.05:1;

<span class="keyword">for</span> i=1:length(y)
    <span class="keyword">for</span> j=1:length(dy)

        u(i,j)=sign(sign(-y(i))*sqrt(2*abs(-y(i)))-dy(j));

    <span class="keyword">end</span>
<span class="keyword">end</span>

pcolor(y,dy,u);
title(<span class="string">'Mapa de cores da Fun&ccedil;&atilde;o de Gera&ccedil;&atilde;o da Entrada'</span>);
ylabel(<span class="string">'$\dot y(t)$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
xlabel(<span class="string">'y(t)'</span>);
set(gca,<span class="string">'fontsize'</span>,12)
colorbar;
</pre><img vspace="5" hspace="5" src="Lab2_11.png" alt=""> <p>Nesta quest&atilde;o, representou-se a tens&atilde;o, u, em fun&ccedil;&atilde;o da posi&ccedil;&atilde;o e velocidade do sistema. Para este efeito utilizou-se a express&atilde;o:</p><p><img src="Lab2_eq14140430267268751476.png" alt="$u=sign(-y)\sqrt{2|y|}-\dot y$"></p><p>A partir do gr&aacute;fico obtido, podemos concluir que, como neste caso a nossa refer&ecirc;ncia &eacute; 0, o sistema vai evoluir sempre para a origem. Relativamente ao funcionamento global da estrutura de controlo:</p><div><ul><li>Quando y&gt;0 e <img src="Lab2_eq01459222511969220698.png" alt="$\dot y$">&gt;0, para que a cabe&ccedil;a magn&eacute;tica convirja para a origem &eacute;   necess&aacute;rio que a velocidade diminua, logo u=-1.</li><li>Quando y&lt;0 e <img src="Lab2_eq01459222511969220698.png" alt="$\dot y$">&lt;0, para que a velocidade diminua em m&oacute;dulo &eacute;   necess&aacute;rio que u=1.</li><li>Quando y&lt;0 e <img src="Lab2_eq01459222511969220698.png" alt="$\dot y$">&gt;0 ou y&lt;0 e <img src="Lab2_eq01459222511969220698.png" alt="$\dot y$">&gt;0, quanto mais afastada   estiver a cabe&ccedil;a da origem, para pequenos valores de velocidade n&atilde;o se   consegue atingir a mesma, logo &eacute; necess&aacute;rio aumentar a velocidade em m&oacute;dulo.   De seguida, quando a cabe&ccedil;a se encontra mais pr&oacute;xima da origem, come&ccedil;a-se a diminuir   a velocidade, de forma a chegar &agrave; posi&ccedil;&atilde;o de refer&ecirc;ncia com velocidade   0.</li></ul></div><h2>Pergunta 9<a name="20"></a></h2><p>Para esta quest&atilde;o foi realizado o diagrama de blocos da fig.4(b) do enunciado no SIMULINK.</p><pre class="codeinput">open(<span class="string">'sim8'</span>);
open_system(<span class="string">'sim8/Subsystem'</span>,<span class="string">'window'</span>);
</pre><img vspace="5" hspace="5" src="Lab2_12.png" alt=""> <img vspace="5" hspace="5" src="Lab2_13.png" alt=""> <p>A fun&ccedil;&atilde;o inserida no Subsystem foi a seguinte:</p><p>function y = fcn(u)</p><p>y=sign(u)*sqrt(2*abs(u));</p><p>end</p><pre class="codeinput">clear
close <span class="string">all</span>

dy_inicial=0; <span class="comment">%condi&ccedil;&otilde;es iniciais</span>
y_inicial=1;
K=10000; <span class="comment">%Ganho</span>

sim(<span class="string">'sim8'</span>);

plot(y,dy);
ylabel(<span class="string">'$\dot y(t)$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
xlabel(<span class="string">'y(t)'</span>);
title(<span class="string">'Curva de Comuta&ccedil;&atilde;o'</span>);
grid <span class="string">on</span>;
set(gca,<span class="string">'Fontsize'</span>,12);

figure;
plot(t,u);
xlabel(<span class="string">'t [s]'</span>);
ylabel(<span class="string">'u(t)'</span>);
title(<span class="string">'Sinal u(t)'</span>);
grid <span class="string">on</span>;
set(gca,<span class="string">'Fontsize'</span>,12);

figure;
plot(t,dy);
xlabel(<span class="string">'t [s]'</span>);
ylabel(<span class="string">'$\dot y(t)$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
title(<span class="string">'Velocidade em fun&ccedil;&atilde;o do tempo'</span>);
grid <span class="string">on</span>;
set(gca,<span class="string">'Fontsize'</span>,12);

figure;
plot(t,y);
xlabel(<span class="string">'t [s]'</span>);
ylabel(<span class="string">'y(t)'</span>);
title(<span class="string">'Posi&ccedil;&atilde;o em fun&ccedil;&atilde;o do tempo'</span>);
grid <span class="string">on</span>;
set(gca,<span class="string">'Fontsize'</span>,12);
</pre><img vspace="5" hspace="5" src="Lab2_14.png" alt=""> <img vspace="5" hspace="5" src="Lab2_15.png" alt=""> <img vspace="5" hspace="5" src="Lab2_16.png" alt=""> <img vspace="5" hspace="5" src="Lab2_17.png" alt=""> <p>Tanto a estrat&eacute;gia em malha aberta como em malha fechada s&atilde;o v&aacute;lidas, pois ambas conduzem a cabe&ccedil;a magn&eacute;tica para a posi&ccedil;&atilde;o desejada em tempo finito. No entanto, na estrat&eacute;gia em malha fechada, o sistema &eacute; mais r&aacute;pido a atingir esta posi&ccedil;&atilde;o.</p><p>Como podemos verificar pelo gr&aacute;fico obtido na quest&atilde;o 8, a origem est&aacute; em cima da linha de descontinuidade do sinal de controlo u. Desta forma, o sinal n&atilde;o estabiliza e fica a variar entre <img src="Lab2_eq11323801440510160924.png" alt="$\pm 1$">.</p><p>Este comportamento, conhecido por chattering, &eacute; problem&aacute;tico, uma vez que se o sinal de controlo n&atilde;o estabiliza ent&atilde;o o sistema tamb&eacute;m n&atilde;o estabiliza, mantendo-se &agrave; volta da origem.</p><h2>Pergunta 10<a name="25"></a></h2><p>Foi criada a seguinte fun&ccedil;&atilde;o, "u_valor", para a gera&ccedil;&atilde;o do sinal de controlo, <img src="Lab2_eq14810136366484092638.png" alt="$u(y,\dot y)$">, tendo em conta a regi&atilde;o a tracejado no diagrama de blocos da figura 5 do enunciado.</p><pre class="codeinput">type(<span class="string">'u_valor.m'</span>);
</pre><pre class="codeoutput">
function u=u_valor(y,dy,yl)

k1=1/yl;
k2=sqrt(2*k1);

 if abs(-y)&lt;=yl
     f=(k1/k2)*(-y);
 elseif abs(-y)&gt;yl
     f=sign(-y)*(sqrt(2*abs(-y))-(1/k2));
 end
 
 u=sign(f-dy);
 
end
</pre><pre class="codeinput">clear
close <span class="string">all</span>

y=-1:0.05:1;
dy=-1:0.05:1;
yl=0.05;

<span class="keyword">for</span> i=1:length(y)
    <span class="keyword">for</span> j=1:length(dy)

        u(i,j)=u_valor(y(i),dy(j),yl);

    <span class="keyword">end</span>
<span class="keyword">end</span>

pcolor(y,dy,u);
title(<span class="string">'Mapa de cores da Fun&ccedil;&atilde;o de Gera&ccedil;&atilde;o da Entrada'</span>);
ylabel(<span class="string">'$\dot y(t)$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>,<span class="string">'Fontsize'</span>,14);
xlabel(<span class="string">'y(t)'</span>,<span class="string">'Fontsize'</span>,14);
colorbar;
</pre><img vspace="5" hspace="5" src="Lab2_18.png" alt=""> <p>A arquitetura modificada da figura 5 do enunciado permite, ao contr&aacute;rio da anterior, que o sinal de controlo tome valores diferentes de <img src="Lab2_eq11323801440510160924.png" alt="$\pm 1$"> em torno da origem. Este efeito deve-se &agrave; defini&ccedil;&atilde;o de um intervalo entre <img src="Lab2_eq07430375362886839849.png" alt="$\pm y_l$">, onde o sistema &eacute; linear e ao ajuste do ganho para <img src="Lab2_eq00029312330466126760.png" alt="$k_2$">.</p><p>Desta forma, quando a posi&ccedil;&atilde;o da cabe&ccedil;a magn&eacute;tica se encontra na vizinhan&ccedil;a da origem, u(t) converge para um valor fixo, evitando o efeito de chattering.</p><h2>Pergunta 11<a name="29"></a></h2><p>Para esta quest&atilde;o foi realizado o diagrama de blocos da fig.5 do enunciado no SIMULINK.</p><pre class="codeinput">open(<span class="string">'sim10'</span>);
open_system(<span class="string">'sim10/Subsystem'</span>,<span class="string">'window'</span>);
</pre><img vspace="5" hspace="5" src="Lab2_19.png" alt=""> <img vspace="5" hspace="5" src="Lab2_20.png" alt=""> <p>Para o bloco 'Ramo de baixo' inseriu-se a fun&ccedil;&atilde;o:</p><p>function f = fcn(y,k2)</p><p>f=sign(y)*(sqrt(2*abs(y))-(1/k2));</p><p>end</p><p>Para o bloco 'Ramo de cima' inseriu-se a fun&ccedil;&atilde;o:</p><p>function f = fcn(y,k1,k2)</p><p>f=(k1/k2)*(y);</p><p>end</p><p>Para o ficheiro Simulink 'sim10_rs', apenas se alterou o Subsystem. Neste s&oacute; se manteve o bloco 'Ramo de cima', com a fun&ccedil;&atilde;o j&aacute; indicada.</p><pre class="codeinput">open(<span class="string">'sim10_rs'</span>);
</pre><img vspace="5" hspace="5" src="Lab2_21.png" alt=""> <pre class="codeinput">clear
close <span class="string">all</span>

dy_inicial=0;
y_inicial=1;
yl=0.05;
k1=1/yl;
k2=sqrt(2*k1);
K=10000;

sim(<span class="string">'sim8'</span>);

figure(1);
plot(y,dy);
ylabel(<span class="string">'$\dot y(t)$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
xlabel(<span class="string">'y(t)'</span>);
title(<span class="string">'Curva de Comuta&ccedil;&atilde;o'</span>);
grid <span class="string">on</span>;
set(gca,<span class="string">'Fontsize'</span>,14);
hold <span class="string">on</span>;

figure(2);
plot(t,u);
xlabel(<span class="string">'t [s]'</span>);
ylabel(<span class="string">'u(t)'</span>);
title(<span class="string">'Sinal u(t)'</span>);
grid <span class="string">on</span>;
set(gca,<span class="string">'Fontsize'</span>,14);
xlim([0 8]);
hold <span class="string">on</span>;

figure(3);
plot(t,dy);
xlabel(<span class="string">'t [s]'</span>);
ylabel(<span class="string">'$\dot y(t)$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
title(<span class="string">'Velocidade em fun&ccedil;&atilde;o do tempo'</span>);
grid <span class="string">on</span>;
set(gca,<span class="string">'Fontsize'</span>,14);
xlim([0 8]);
hold <span class="string">on</span>;

figure(4);
plot(t,y);
xlabel(<span class="string">'t [s]'</span>);
ylabel(<span class="string">'y(t)'</span>);
title(<span class="string">'Posi&ccedil;&atilde;o em fun&ccedil;&atilde;o do tempo'</span>);
grid <span class="string">on</span>;
set(gca,<span class="string">'Fontsize'</span>,14);
xlim([0 8]);
hold <span class="string">on</span>;

sim(<span class="string">'sim10'</span>);

figure(1);
plot(y,dy);
hold <span class="string">on</span>;

figure(2);
plot(t,u);
hold <span class="string">on</span>;

figure(3);
plot(t,dy);
hold <span class="string">on</span>;

figure(4);
plot(t,y);
hold <span class="string">on</span>;

sim(<span class="string">'sim10_rs'</span>);

figure(1);
plot(y,dy);
lg=legend(<span class="string">'Com chattering'</span>,<span class="string">'Sem chattering'</span>,<span class="string">'Ramo superior'</span>);
set(lg,<span class="string">'Fontsize'</span>,12);

figure(2);
plot(t,u);
lg=legend(<span class="string">'Com chattering'</span>,<span class="string">'Sem chattering'</span>,<span class="string">'Ramo superior'</span>);
set(lg,<span class="string">'Fontsize'</span>,12);

figure(3);
plot(t,dy);
lg=legend(<span class="string">'Com chattering'</span>,<span class="string">'Sem chattering'</span>,<span class="string">'Ramo superior'</span>,<span class="string">'Location'</span>,<span class="string">'southeast'</span>);
set(lg,<span class="string">'Fontsize'</span>,12);

figure(4);
plot(t,y);
lg=legend(<span class="string">'Com chattering'</span>,<span class="string">'Sem chattering'</span>,<span class="string">'Ramo superior'</span>);
set(lg,<span class="string">'Fontsize'</span>,12);
</pre><img vspace="5" hspace="5" src="Lab2_22.png" alt=""> <img vspace="5" hspace="5" src="Lab2_23.png" alt=""> <img vspace="5" hspace="5" src="Lab2_24.png" alt=""> <img vspace="5" hspace="5" src="Lab2_25.png" alt=""> <p>Como se pode verificar pelos gr&aacute;ficos obtidos, o sinal de controlo da arquitetura modificada n&atilde;o apresenta oscila&ccedil;&otilde;es, como pretendido. Neste caso, quando a posi&ccedil;&atilde;o da cabe&ccedil;a se encontra na vizinhan&ccedil;a da origem, o sinal u(t) converge para 0. Tamb&eacute;m se observa uma evolu&ccedil;&atilde;o do sistema mais suave comparativamente ao sistema da quest&atilde;o anterior. No entanto, a arquitectura anterior &eacute; ligeiramente mais r&aacute;pida a atingir a posi&ccedil;&atilde;o final pretendida.</p><p>Comparando ainda com a resposta do sistema em apenas se considera o ramo superior da fun&ccedil;&atilde;o f(x), podemos concluir que, apesar de tamb&eacute;m n&atilde;o haver chattering, a degrada&ccedil;&atilde;o no tempo de resposta &eacute; bastante superior comparativamente &agrave;s duas estruturas simuladas.</p><p>Daqui, retira-se que a melhor estrutura a utilizar &eacute; a apresentada na figura 5, pois evita o efeito de chattering e tem um tempo de resposta aceit&aacute;vel.</p><h2>Pergunta 12<a name="39"></a></h2><p>Para esta quest&atilde;o foi realizado o diagrama de blocos da fig.5 do enunciado, juntamente com a constante b que modela o efeito de atrito no SIMULINK. O bloco Subsystem &eacute; igual ao do ficheiro 'sim10', j&aacute; apresentado.</p><pre class="codeinput">open(<span class="string">'sim12'</span>);
open_system(<span class="string">'sim12/Subsystem'</span>,<span class="string">'window'</span>);
</pre><img vspace="5" hspace="5" src="Lab2_26.png" alt=""> <img vspace="5" hspace="5" src="Lab2_27.png" alt=""> <pre class="codeinput">clear
close <span class="string">all</span>

dy_inicial=0;
y_inicial=1;
yl=0.1;
k1=1/yl;
k2=sqrt(2*k1);
b=0.025;
n1=400;
n2=400;

sim(<span class="string">'sim12'</span>);

figure(1);
plot(y,dy);
ylabel(<span class="string">'$\dot y(t)$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
xlabel(<span class="string">'y(t)'</span>);
title(<span class="string">'Curva de Comuta&ccedil;&atilde;o'</span>);
grid <span class="string">on</span>;
set(gca,<span class="string">'Fontsize'</span>,12);
hold <span class="string">on</span>;

figure(2);
plot(t,u);
xlabel(<span class="string">'t [s]'</span>);
ylabel(<span class="string">'u(t)'</span>);
title(<span class="string">'Sinal u(t)'</span>);
grid <span class="string">on</span>;
set(gca,<span class="string">'Fontsize'</span>,12);
xlim([0 8]);
hold <span class="string">on</span>;

figure(3);
plot(t,dy);
xlabel(<span class="string">'t [s]'</span>);
ylabel(<span class="string">'$\dot y(t)$'</span>,<span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
title(<span class="string">'Velocidade em fun&ccedil;&atilde;o do tempo'</span>);
grid <span class="string">on</span>;
set(gca,<span class="string">'Fontsize'</span>,12);
xlim([0 8]);
hold <span class="string">on</span>;

figure(4);
plot(t,y);
xlabel(<span class="string">'t [s]'</span>);
ylabel(<span class="string">'y(t)'</span>);
title(<span class="string">'Posi&ccedil;&atilde;o em fun&ccedil;&atilde;o do tempo'</span>);
grid <span class="string">on</span>;
set(gca,<span class="string">'Fontsize'</span>,12);
xlim([0 8]);
hold <span class="string">on</span>;
</pre><img vspace="5" hspace="5" src="Lab2_28.png" alt=""> <img vspace="5" hspace="5" src="Lab2_29.png" alt=""> <img vspace="5" hspace="5" src="Lab2_30.png" alt=""> <img vspace="5" hspace="5" src="Lab2_31.png" alt=""> <p>Na quest&atilde;o 7, verificou-se que para a configura&ccedil;&atilde;o em cadeia aberta, uma pequena perturba&ccedil;&atilde;o conduzia o sistema para uma configura&ccedil;&atilde;o final diferente da desejada. No caso da configura&ccedil;&atilde;o em cadeia fechada, tal n&atilde;o se verifica. Mesmo com a presen&ccedil;a de atrito, a posi&ccedil;&atilde;o e a velocidade finais da cabe&ccedil;a s&atilde;o as pretendidas.</p><p>Podemos concluir que a configura&ccedil;&atilde;o em malha fechada apresenta uma maior robustez relativamente &agrave; de malha aberta, ou seja, tem uma maior capacidade de rejeitar perturba&ccedil;&otilde;es aplicadas no sistema.</p><h2>Pergunta 13<a name="43"></a></h2><p>Simulou-se a arquitectura da figura 5, aplicando &agrave; entrada uma refer&ecirc;ncia de sinais constantes, a partir da soma de "Steps" com diferentes amplitudes.</p><pre class="codeinput">open(<span class="string">'sim13_constantes'</span>);
open_system(<span class="string">'sim13_constantes/Subsystem'</span>,<span class="string">'window'</span>);
</pre><img vspace="5" hspace="5" src="Lab2_32.png" alt=""> <img vspace="5" hspace="5" src="Lab2_33.png" alt=""> <p>Aplicou-se &agrave; entrada "Ref" sequ&ecirc;ncias de rampas, a partir do bloco "Repeting sequence" do SIMULINK.</p><pre class="codeinput">open(<span class="string">'sim13_rampas'</span>);
open_system(<span class="string">'sim13_rampas/Subsystem'</span>,<span class="string">'window'</span>);
</pre><img vspace="5" hspace="5" src="Lab2_34.png" alt=""> <img vspace="5" hspace="5" src="Lab2_35.png" alt=""> <p>Os blocos Subsystem de ambos os ficheiros, apresentam o mesmo conte&uacute;do do bloco Subsystem do ficheiro 'sim10' j&aacute; apresentado.</p><pre class="codeinput">clear
close <span class="string">all</span>

dy_inicial=0;
y_inicial=1;
yl=0.1;
k1=1/yl;
k2=sqrt(2*k1);

sim(<span class="string">'sim13_constantes'</span>);
plot(tout,const,t,y);
xlabel(<span class="string">'t [s]'</span>);
ylabel(<span class="string">'y'</span>);
title(<span class="string">'Sinais constantes - Posi&ccedil;&atilde;o'</span>);
grid <span class="string">on</span>;
set(gca,<span class="string">'Fontsize'</span>,12);
legend(<span class="string">'Ref'</span>,<span class="string">'y(t)'</span>,<span class="string">'Location'</span>,<span class="string">'northwest'</span>);

t_rampa=10; <span class="comment">%dura&ccedil;&atilde;o de cada impulso</span>
tt=30; <span class="comment">%tempo de simula&ccedil;&atilde;o total</span>
sim(<span class="string">'sim13_rampas'</span>);

figure(2);
plot(tout,rampa,t,y);
xlabel(<span class="string">'t [s]'</span>);
ylabel(<span class="string">'y'</span>);
title(<span class="string">'Sequ&ecirc;ncias de Rampas - Posi&ccedil;&atilde;o'</span>);
grid <span class="string">on</span>;
set(gca,<span class="string">'Fontsize'</span>,12);
legend(<span class="string">'Ref'</span>,<span class="string">'y(t)'</span>,<span class="string">'Location'</span>,<span class="string">'northwest'</span>);

t_rampa=2;
tt=10;
sim(<span class="string">'sim13_rampas'</span>);

figure(3);
plot(tout,rampa,t,y);
xlabel(<span class="string">'t [s]'</span>);
ylabel(<span class="string">'y'</span>);
title(<span class="string">'Sequ&ecirc;ncias de Rampas (com menor tempo entre rampas)'</span>);
grid <span class="string">on</span>;
set(gca,<span class="string">'Fontsize'</span>,12);
legend(<span class="string">'Ref'</span>,<span class="string">'y(t)'</span>,<span class="string">'Location'</span>,<span class="string">'northwest'</span>);
</pre><img vspace="5" hspace="5" src="Lab2_36.png" alt=""> <img vspace="5" hspace="5" src="Lab2_37.png" alt=""> <img vspace="5" hspace="5" src="Lab2_38.png" alt=""> <p>Para a figura 1 e 2 verifica-se uma boa fidelidade do seguimento da refer&ecirc;ncia por parte do sistema, uma vez que se d&aacute; tempo suficiente ao sistema para mudar de posi&ccedil;&atilde;o e estabilizar.</p><p>No caso da figura 3, onde se diminui o per&iacute;odo do sinal, a mudan&ccedil;a da refer&ecirc;ncia &eacute; demasiado brusca para o sistema a conseguir acompanhar.</p><p>Apesar desta sensibilidade, podemos concluir que o sistema da figura 5 &eacute; a melhor op&ccedil;&atilde;o de controlo do sistema.</p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% 2º Laboratório de Modelação e Simulação 2019/20
% Optimização do servomecanismo de um disco rígido
%
% Alice Rosa, nº 90007 
%
% Beatriz Pereira, nº 90029 
%
% Grupo 16, Turno 3ª feira às 9h00 
%% Pergunta 2
%
% Foi criada a seguinte função, "imp_prot", para a geração do impulso
% protótipo.

%% 
type('imp_prot.m');

%%
% Nesta função, deu-se uso às expressões analíticas deduzidas na alínea 1,
% obtendo-se para cada intervalo adequado o valor de $p_\beta(t)$. No
% final, concatenaram-se todas as partes para se obter o impulso
% protótipo.

%% 
clear
t=-1:0.01:1;
beta_set=[0 0.2 0.7 1];

for i=1:length(beta_set)
 beta=beta_set(i);
 pbeta=imp_prot(t,beta); 
 figure(1);
 plot(t,pbeta);
 hold on;
end

xlabel('t [s]');
ylabel('$p_\beta(t)$','interpreter','latex');
title('Impulso Protótipo');
set(gca,'Fontsize',14);
lg=legend(sprintf('\\beta=%.1f',beta_set(1)),sprintf('\\beta=%.1f',beta_set(2)),...
    sprintf('\\beta=%.1f',beta_set(3)),sprintf('\\beta=%.1f',beta_set(4)));
set(lg,'Fontsize',10);

%%
% Geraram-se 4 impulsos protótipos, para diferentes $\beta$, de forma a 
% evidenciar a influência deste na forma do impulso.
%
% Como se pode verificar, o parâmetro $\beta$ influencia a duração total do
% impulso e a duração dos flancos acendentes e descentes do mesmo.
%
% * Para $\beta=0$, o impulso gerado é rectangular, ou seja, o tempo de
% descida e subida são nulos.
% * Para $0<\beta<1$, verifica-se o aumento gradual dos tempos
% de subida e descida com o aumento de $\beta$.
% * Para $\beta=1$, a tempo de subida é igual ao tempo de descida e a soma
% dos dois corresponde à duração total do impulso.

%% Pergunta 3
%
% Foi criada a seguinte função, "sinal_entrada", para a geração do sinal de
% controlo, $u(t)$. 
%% 
type('sinal_entrada.m');

%%
% Nesta função, realizaram-se transformações na amplitude e no tempo a partir
% do impulso protótipo. O primeiro impulso é multiplicado pela amplitude
% U1, expandido no tempo de acordo com o factor $\mu_1=T1/(1+\beta)$ e avançado
% $T_1/2$. As mesmas transformações de amplitude e de expansão foram
% realizadas para o segundo impulso com a amplitude U2 e período T2, este
% foi avançado no tempo de forma ao seu início corresponder ao final do
% primeiro impulso.

%% 
clear
close all

T=5;
alpha_set=[0.5 1 1.5];
beta=0.5;
U1=1;
U2=1;
n1=400;
n2=400;

for i=1:length(alpha_set)
 alpha=alpha_set(i);
 [u,t]=sinal_entrada(T,alpha,beta,U1,U2,n1,n2);
 figure(1);
 plot(t,u);
 hold on;
end

xlim([t(1) t(length(t))]);
xlabel('t [s]');
ylabel('$u(t)$','interpreter','latex');
title('Sinal de Controlo');
set(gca,'Fontsize',14);
grid on;
legend(sprintf('\\alpha=%.1f',alpha_set(1)),sprintf('\\alpha=%.1f',alpha_set(2)),...
    sprintf('\\alpha=%.1f',alpha_set(3)),'Location','northwest');
%%
% Geraram-se 3 sinais de controlo, para diferentes valores de $\alpha$, de forma a 
% evidenciar a influência deste na forma do sinal.
% Como se pode verificar, o parâmetro $\alpha$ influencia os parâmetros T1 
% e T2 do sinal.
%
% * Para $0<\alpha<1$, T1>T2, ou seja, a duração do primeiro impulso é
% superior à do segundo.
% * Para $\alpha>1$, T1<T2.

%% Pergunta 7
%
% Para esta questão, realizou-se a simulação do sistema em malha aberta,
% onde, a partir das expressões obtidas na alínea 6, gera-se o sinal de
% controlo $u(t)$ e obtém-se os valores da posição e velocidade da cabeça
% sobre o disco, resolvendo a seguinte equação diferencial:
%
% $\ddot y(t)=u-b\dot y$
%
% Onde b é uma constante associada a um termo que modela o efeito de
% atrito.
%
% Para obter os valores da posição e velocidade utilizou-se o
% seguinte diagrama de blocos desenvolvido no SIMULINK:

%%
open('sim7');
%%
clear
close all

alpha=[0.5 1 1.5];
beta=[0.5 0.5 0.5];
n1=400;
n2=400;
y_inicial=1;
dy_inicial=0;
b=0;

for i=1:length(alpha);
    
    if alpha(i)>0 && alpha(i)<=1
        T=sqrt((2/alpha(i))*(1+beta(i))*(1+alpha(i)));
    elseif alpha(i)>1
        T=sqrt(2*(1+beta(i))*(1+alpha(i)));
    end
    
    T1=T/(1+alpha(i));
    U1=(2*(1+beta(i)))/(T1^2*(1+alpha(i)));
    U2=U1/alpha(i);
    
    [u,t]=sinal_entrada(T,alpha(i),beta(i),U1,U2,n1,n2);
    figure(1);
    plot(t,u);
    hold on;
    
    sinal.time=t';
    sinal.signals.values=u';
    sinal.signals.dimensions=1;
    sim('sim7');
    
    figure(2);
    plot(tout,dy);
    hold on;
     
    figure(3);
    plot(tout,y);
    hold on;
    
    figure(4);
    plot(y,dy);
    hold on;
    
end
   
figure(1);
xlabel('t [s]');
ylabel('$u(t)$','interpreter','latex');
title('Sinais de Controlo');
grid on;
set(gca,'fontsize',12);
legend(sprintf('\\alpha=%.1f \\beta=%.1f',alpha(1),beta(1)),...
    sprintf('\\alpha=%.1f \\beta=%.1f',alpha(2),beta(2)),...
    sprintf('\\alpha=%.1f \\beta=%.1f',alpha(3),beta(3)),'Location','northwest');

figure(2);
xlabel('t [s]');
ylabel('$\dot y(t)$','interpreter','latex');
title('Velocidade');
grid on;
set(gca,'fontsize',12);
legend(sprintf('\\alpha=%.1f \\beta=%.1f',alpha(1),beta(1)),...
    sprintf('\\alpha=%.1f \\beta=%.1f',alpha(2),beta(2)),...
    sprintf('\\alpha=%.1f \\beta=%.1f',alpha(3),beta(3)),'Location','southeast');
  
figure(3);
ylim([0 1]);
xlabel('t [s]');
ylabel('y(t)');
title('Posição');
grid on;
set(gca,'fontsize',12);
legend(sprintf('\\alpha=%.1f \\beta=%.1f',alpha(1),beta(1)),...
    sprintf('\\alpha=%.1f \\beta=%.1f',alpha(2),beta(2)),...
    sprintf('\\alpha=%.1f \\beta=%.1f',alpha(3),beta(3)));

figure(4);
xlabel('y(t)');
ylabel('$\dot y(t)$','interpreter','latex');
title('Curvas de Comutação');
grid on;
set(gca,'fontsize',12);
legend(sprintf('\\alpha=%.1f \\beta=%.1f',alpha(1),beta(1)),...
    sprintf('\\alpha=%.1f \\beta=%.1f',alpha(2),beta(2)),...
    sprintf('\\alpha=%.1f \\beta=%.1f',alpha(3),beta(3)));
   
 %%
 % Na figura 1, podemos observar os sinais de controlo obtidos a partir dos
 % parâmetros deduzidos, tendo em atenção que T($\alpha$=0.5)= 3 s,
 % T($\alpha$=1)= 2.7 e T($\alpha$=1.5)=2.48 s, aproximadamente. 
 %
 % A partir das figuras 2,3 e 4, verificámos a validade das expressões 
 % analíticas obtidas na alínea 6, uma vez que para os 3 pares de
 % $\alpha,\beta$ obtemos as configurações finais desejadas, y(T)=0 e $\dot
 % y(T)=0$.
 %
 % Também podemos verificar que, tal como foi deduzido, o valor de $\alpha$
 % que minimiza T é 1.
 %
 % De seguida, obtém-se os mesmos gráficos, mas agora com o sistema
 % perturbado com b=0.025.
 
 %%
 close all
 
 b=0.025;
   
for i=1:length(alpha);
    
    if alpha(i)>0 && alpha(i)<=1
        T=sqrt((2/alpha(i))*(1+beta(i))*(1+alpha(i)));
    elseif alpha(i)>1
        T=sqrt(2*(1+beta(i))*(1+alpha(i)));
    end
    
    T1=T/(1+alpha(i));
    U1=(2*(1+beta(i)))/(T1^2*(1+alpha(i)));
    U2=U1/alpha(i);
    
    [u,t]=sinal_entrada(T,alpha(i),beta(i),U1,U2,n1,n2);
    
    sinal.time=t';
    sinal.signals.values=u';
    sinal.signals.dimensions=1;
    sim('sim7');
    
    figure(1);
    plot(tout,dy);
    hold on;
     
    figure(2);
    plot(tout,y);
    hold on;
    
    figure(3);
    plot(y,dy);
    hold on;
    
end

figure(1);
xlabel('t [s]');
ylabel('$\dot y(t)$','interpreter','latex');
title('Velocidade');
grid on;
set(gca,'fontsize',12);
legend(sprintf('\\alpha=%.1f \\beta=%.1f',alpha(1),beta(1)),...
    sprintf('\\alpha=%.1f \\beta=%.1f',alpha(2),beta(2)),...
    sprintf('\\alpha=%.1f \\beta=%.1f',alpha(3),beta(3)),'Location','southeast');
  
figure(2);
ylim([0 1]);
xlabel('t [s]');
ylabel('y(t)');
title('Posição');
grid on;
set(gca,'fontsize',12);
legend(sprintf('\\alpha=%.1f \\beta=%.1f',alpha(1),beta(1)),...
    sprintf('\\alpha=%.1f \\beta=%.1f',alpha(2),beta(2)),...
    sprintf('\\alpha=%.1f \\beta=%.1f',alpha(3),beta(3)));

figure(3);
xlabel('y(t)');
ylabel('$\dot y(t)$','interpreter','latex');
title('Curvas de Comutação');
grid on;
set(gca,'fontsize',12);
legend(sprintf('\\alpha=%.1f \\beta=%.1f',alpha(1),beta(1)),...
    sprintf('\\alpha=%.1f \\beta=%.1f',alpha(2),beta(2)),...
    sprintf('\\alpha=%.1f \\beta=%.1f',alpha(3),beta(3)));

%%
% Nesta situação, verifica-se que o estudo feito teoricamente já não é
% válido. O sistema não é conduzido para a configuração final
% desejada, visto que $y(T) \neq 0$ e $\dot y(T) \neq 0$. Desta forma,
% como se pode observar nas figuras da posição e velocidade, a cabeça
% magnética permanece em movimento, sem atingir o equílibrio.
% 
% Pode-se concluir que o sistema em malha aberta é bastante sensível a
% perturbações. Para contornar este problema recorre-se a um sistema em
% malha fechada, pois este altera o sinal de controlo tendo em conta a
% evolução do sistema.


%% Pergunta 8 

%%
clear
close all

y=-1:0.05:1;
dy=-1:0.05:1;

for i=1:length(y)
    for j=1:length(dy)
        
        u(i,j)=sign(sign(-y(i))*sqrt(2*abs(-y(i)))-dy(j));
        
    end
end

pcolor(y,dy,u);
title('Mapa de cores da Função de Geração da Entrada');
ylabel('$\dot y(t)$','interpreter','latex');
xlabel('y(t)');
set(gca,'fontsize',12)
colorbar;
%%
% Nesta questão, representou-se a tensão, u, em função da posição e
% velocidade do sistema. Para este efeito utilizou-se a expressão:
%
% $u=sign(-y)\sqrt{2|y|}-\dot y$
%
% A partir do gráfico obtido, podemos concluir que, como neste caso a nossa 
% referência é 0, o sistema vai evoluir sempre para a origem. Relativamente
% ao funcionamento global da estrutura de controlo:
%
% * Quando y>0 e $\dot y$>0, para que a cabeça magnética convirja para a origem é
%   necessário que a velocidade diminua, logo u=-1.
% * Quando y<0 e $\dot y$<0, para que a velocidade diminua em módulo é
%   necessário que u=1.
% * Quando y<0 e $\dot y$>0 ou y<0 e $\dot y$>0, quanto mais afastada
%   estiver a cabeça da origem, para pequenos valores de velocidade não se
%   consegue atingir a mesma, logo é necessário aumentar a velocidade em módulo. 
%   De seguida, quando a cabeça se encontra mais próxima da origem, começa-se a diminuir
%   a velocidade, de forma a chegar à posição de referência com velocidade
%   0.
%
%% Pergunta 9
% 
% Para esta questão foi realizado o diagrama de blocos da fig.4(b) do
% enunciado no SIMULINK.
%%
open('sim8');
open_system('sim8/Subsystem','window');

%%
% A função inserida no Subsystem foi a seguinte:
%
% function y = fcn(u)
%  
% y=sign(u)*sqrt(2*abs(u));
% 
% end

%%
clear
close all

dy_inicial=0; %condições iniciais
y_inicial=1;
K=10000; %Ganho 

sim('sim8');

plot(y,dy);
ylabel('$\dot y(t)$','interpreter','latex');
xlabel('y(t)');
title('Curva de Comutação');
grid on;
set(gca,'Fontsize',12);

figure;
plot(t,u);
xlabel('t [s]');
ylabel('u(t)');
title('Sinal u(t)');
grid on;
set(gca,'Fontsize',12);

figure;
plot(t,dy);
xlabel('t [s]');
ylabel('$\dot y(t)$','interpreter','latex');
title('Velocidade em função do tempo');
grid on;
set(gca,'Fontsize',12);

figure;
plot(t,y);
xlabel('t [s]');
ylabel('y(t)');
title('Posição em função do tempo');
grid on;
set(gca,'Fontsize',12);

%%
% Tanto a estratégia em malha aberta como em malha fechada são válidas, pois
% ambas conduzem a cabeça magnética para a posição desejada em tempo finito.
% No entanto, na estratégia em malha fechada, o sistema é mais rápido a 
% atingir esta posição. 
% 
% Como podemos verificar pelo gráfico obtido na questão 8, a origem está
% em cima da linha de descontinuidade do sinal de controlo u. Desta forma,
% o sinal não estabiliza e fica a variar entre $\pm 1$.
% 
% Este comportamento, conhecido por chattering, é problemático,
% uma vez que se o sinal de controlo não estabiliza então o sistema também
% não estabiliza, mantendo-se à volta da origem.

%% Pergunta 10
%
% Foi criada a seguinte função, "u_valor", para a geração do sinal de
% controlo, $u(y,\dot y)$, tendo em conta a região a tracejado no diagrama
% de blocos da figura 5 do enunciado.
%%
type('u_valor.m');
%%
clear
close all

y=-1:0.05:1;
dy=-1:0.05:1;
yl=0.05;

for i=1:length(y)
    for j=1:length(dy)
        
        u(i,j)=u_valor(y(i),dy(j),yl);
        
    end
end

pcolor(y,dy,u);
title('Mapa de cores da Função de Geração da Entrada');
ylabel('$\dot y(t)$','interpreter','latex','Fontsize',14);
xlabel('y(t)','Fontsize',14);
colorbar;

%%
% A arquitetura modificada da figura 5 do enunciado permite, ao contrário 
% da anterior, que o sinal de controlo tome valores diferentes de $\pm 1$ 
% em torno da origem. Este efeito deve-se à definição de um 
% intervalo entre $\pm y_l$, onde o sistema é linear e ao ajuste do ganho 
% para $k_2$.
% 
% Desta forma, quando a posição da cabeça magnética se encontra
% na vizinhança da origem, u(t) converge para um valor fixo, evitando o 
% efeito de chattering.
%

%% Pergunta 11
%
% Para esta questão foi realizado o diagrama de blocos da fig.5 do
% enunciado no SIMULINK.
%%
open('sim10');
open_system('sim10/Subsystem','window');
%%
% Para o bloco 'Ramo de baixo' inseriu-se a função:
%%
% function f = fcn(y,k2)
% 
% f=sign(y)*(sqrt(2*abs(y))-(1/k2));
%
% end
% 
%%
% Para o bloco 'Ramo de cima' inseriu-se a função:
%%
% function f = fcn(y,k1,k2)
% 
% f=(k1/k2)*(y);
% 
% end
%%
% Para o ficheiro Simulink 'sim10_rs', apenas se alterou o Subsystem. Neste
% só se manteve o bloco 'Ramo de cima', com a função já indicada.
%%
open('sim10_rs');
%%
clear
close all

dy_inicial=0;
y_inicial=1;
yl=0.05;
k1=1/yl;
k2=sqrt(2*k1);
K=10000;

sim('sim8');

figure(1);
plot(y,dy);
ylabel('$\dot y(t)$','interpreter','latex');
xlabel('y(t)');
title('Curva de Comutação');
grid on;
set(gca,'Fontsize',14);
hold on;

figure(2);
plot(t,u);
xlabel('t [s]');
ylabel('u(t)');
title('Sinal u(t)');
grid on;
set(gca,'Fontsize',14);
xlim([0 8]);
hold on;

figure(3);
plot(t,dy);
xlabel('t [s]');
ylabel('$\dot y(t)$','interpreter','latex');
title('Velocidade em função do tempo');
grid on;
set(gca,'Fontsize',14);
xlim([0 8]);
hold on;

figure(4);
plot(t,y);
xlabel('t [s]');
ylabel('y(t)');
title('Posição em função do tempo');
grid on;
set(gca,'Fontsize',14);
xlim([0 8]);
hold on;

sim('sim10');

figure(1);
plot(y,dy);
hold on;

figure(2);
plot(t,u);
hold on;

figure(3);
plot(t,dy);
hold on;

figure(4);
plot(t,y);
hold on;

sim('sim10_rs');

figure(1);
plot(y,dy);
lg=legend('Com chattering','Sem chattering','Ramo superior');
set(lg,'Fontsize',12);

figure(2);
plot(t,u);
lg=legend('Com chattering','Sem chattering','Ramo superior');
set(lg,'Fontsize',12);

figure(3);
plot(t,dy);
lg=legend('Com chattering','Sem chattering','Ramo superior','Location','southeast');
set(lg,'Fontsize',12);

figure(4);
plot(t,y);
lg=legend('Com chattering','Sem chattering','Ramo superior');
set(lg,'Fontsize',12);

%%
% Como se pode verificar pelos gráficos obtidos, o sinal de controlo da
% arquitetura modificada não apresenta oscilações, como pretendido. Neste
% caso, quando a posição da cabeça se encontra na vizinhança da origem, o
% sinal u(t) converge para 0. Também se observa uma evolução do sistema
% mais suave comparativamente ao sistema da questão anterior. No entanto,
% a arquitectura anterior é ligeiramente mais rápida a atingir a posição
% final pretendida.
%
% Comparando ainda com a resposta do sistema em apenas se considera o ramo 
% superior da função f(x), podemos concluir que, apesar de também não haver
% chattering, a degradação no tempo de resposta é bastante superior
% comparativamente às duas estruturas simuladas.
%
% Daqui, retira-se que a melhor estrutura a utilizar é a apresentada
% na figura 5, pois evita o efeito de chattering e tem um tempo de resposta
% aceitável.

%% Pergunta 12
%
% Para esta questão foi realizado o diagrama de blocos da fig.5 do
% enunciado, juntamente com a constante b que modela o efeito de atrito 
% no SIMULINK. O bloco Subsystem é igual ao do ficheiro 'sim10', já
% apresentado.
%%
open('sim12');
open_system('sim12/Subsystem','window');
%%
clear
close all

dy_inicial=0;
y_inicial=1;
yl=0.1;
k1=1/yl;
k2=sqrt(2*k1);
b=0.025;
n1=400;
n2=400;

sim('sim12');

figure(1);
plot(y,dy);
ylabel('$\dot y(t)$','interpreter','latex');
xlabel('y(t)');
title('Curva de Comutação');
grid on;
set(gca,'Fontsize',12);
hold on;

figure(2);
plot(t,u);
xlabel('t [s]');
ylabel('u(t)');
title('Sinal u(t)');
grid on;
set(gca,'Fontsize',12);
xlim([0 8]);
hold on;

figure(3);
plot(t,dy);
xlabel('t [s]');
ylabel('$\dot y(t)$','interpreter','latex');
title('Velocidade em função do tempo');
grid on;
set(gca,'Fontsize',12);
xlim([0 8]);
hold on;

figure(4);
plot(t,y);
xlabel('t [s]');
ylabel('y(t)');
title('Posição em função do tempo');
grid on;
set(gca,'Fontsize',12);
xlim([0 8]);
hold on;

%%
% Na questão 7, verificou-se que para a configuração em cadeia aberta, uma
% pequena perturbação conduzia o sistema para uma configuração final
% diferente da desejada. No caso da configuração em cadeia fechada, tal não
% se verifica. Mesmo com a presença de atrito, a posição e a velocidade
% finais da cabeça são as pretendidas. 
%
% Podemos concluir que a configuração em malha fechada apresenta uma maior 
% robustez relativamente à de malha aberta, ou seja, tem uma maior capacidade 
% de rejeitar perturbações aplicadas no sistema.
% 
%% Pergunta 13
%
% Simulou-se a arquitectura da figura 5, aplicando à entrada uma referência
% de sinais constantes, a partir da soma de "Steps" com diferentes
% amplitudes. 
%%
open('sim13_constantes');
open_system('sim13_constantes/Subsystem','window');
%%
% Aplicou-se à entrada "Ref" sequências de rampas, a partir do bloco "Repeting 
% sequence" do SIMULINK.
%%
open('sim13_rampas');
open_system('sim13_rampas/Subsystem','window');
%%
% Os blocos Subsystem de ambos os ficheiros, apresentam o mesmo conteúdo do
% bloco Subsystem do ficheiro 'sim10' já apresentado.
%% 
clear
close all

dy_inicial=0;
y_inicial=1;
yl=0.1;
k1=1/yl;
k2=sqrt(2*k1);

sim('sim13_constantes');
plot(tout,const,t,y);
xlabel('t [s]');
ylabel('y');
title('Sinais constantes - Posição');
grid on;
set(gca,'Fontsize',12);
legend('Ref','y(t)','Location','northwest');

t_rampa=10; %duração de cada impulso
tt=30; %tempo de simulação total
sim('sim13_rampas');

figure(2);
plot(tout,rampa,t,y);
xlabel('t [s]');
ylabel('y');
title('Sequências de Rampas - Posição');
grid on;
set(gca,'Fontsize',12);
legend('Ref','y(t)','Location','northwest');

t_rampa=2;
tt=10;
sim('sim13_rampas');

figure(3);
plot(tout,rampa,t,y);
xlabel('t [s]');
ylabel('y');
title('Sequências de Rampas (com menor tempo entre rampas)');
grid on;
set(gca,'Fontsize',12);
legend('Ref','y(t)','Location','northwest');

%%
% Para a figura 1 e 2 verifica-se uma boa fidelidade do seguimento da
% referência por parte do sistema, uma vez que se dá tempo
% suficiente ao sistema para mudar de posição e estabilizar. 
%
% No caso da figura 3, onde se diminui o período do sinal, a mudança da
% referência é demasiado brusca para o sistema a conseguir acompanhar.
%
% Apesar desta sensibilidade, podemos concluir que o sistema da figura 5 
% é a melhor opção de controlo do sistema.

##### SOURCE END #####
--></body></html>